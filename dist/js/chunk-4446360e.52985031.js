(window.webpackJsonp = window.webpackJsonp || []).push([['chunk-4446360e'], {
  '0798': function (e, t, r) {},
  '1bd0': function (e, t, r) {
    const n = r('f8b7'); const a = r.n(n); a.a;
  },
  '665e': function (e, t, r) {
    const n = r('0798'); const a = r.n(n); a.a;
  },
  e5a2(e, t, r) {
    r.r(t); const n = function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return r('mu-flex', { staticClass: 'container', attrs: { direction: 'column' } }, [r('mu-alert', { attrs: { color: 'info' } }, [e._v('\n    Based on CodeMirror. A simple demo below. Check the document for more information.Â '), r('a', { attrs: { href: 'https://codemirror.net/' } }, [e._v('link to CodeMirror')])]), r('json-editor', { attrs: { val: e.val }, on: { change: e.onChange } })], 1); }; const a = []; const i = function () { const e = this; const t = e.$createElement; const r = e._self._c || t; return r('div', { staticClass: 'json-editor' }, [r('textarea', { ref: 'jsonEditor' })]); }; const o = []; const c = r('56b3'); const s = r.n(c); const u = (r('a7be'), r('f9d4'), {
      props: { val: { type: Object, default() { return {}; } } },
      data() { return { editor: null }; },
      mounted() {
        const e = this; this.editor = s.a.fromTextArea(this.$refs.jsonEditor, {
          mode: 'application/json', tabSize: 2, lineNumbers: !0, lint: !0,
        }), this.editor.setValue(JSON.stringify(this.val)), this.editor.on('change', (t) => { e.$emit('change', t.getValue()); });
      },
      watch: { val(e) { const t = this.editor.getValue(); e !== t && this.editor.setValue(JSON.stringify(this.val, null, 2)); } },
    }); const l = u; const f = (r('665e'), r('2877')); const d = Object(f.a)(l, i, o, !1, null, '6af97ce8', null); const p = d.exports; const m = { components: { JsonEditor: p }, data() { return { val: {} }; }, methods: { onChange(e) { this.val = e; } } }; const v = m; const k = (r('1bd0'), Object(f.a)(v, n, a, !1, null, '6ed5a054', null)); t.default = k.exports;
  },
  f8b7(e, t, r) {},
  f9d4(e, t, r) {
    (function (e) { e(r('56b3')); }((e) => {
      e.defineMode('javascript', (t, r) => {
        let n; let a; const i = t.indentUnit; const o = r.statementIndent; const c = r.jsonld; const s = r.json || c; const u = r.typescript; const l = r.wordCharacters || /[\w$\xa1-\uffff]/; const f = (function () {
          function e(e) { return { type: e, style: 'keyword' }; } const t = e('keyword a'); const r = e('keyword b'); const n = e('keyword c'); const a = e('keyword d'); const i = e('operator'); const o = { type: 'atom', style: 'atom' }; return {
            if: e('if'), while: t, with: t, else: r, do: r, try: r, finally: r, return: a, break: a, continue: a, new: e('new'), delete: n, void: n, throw: n, debugger: e('debugger'), var: e('var'), const: e('var'), let: e('var'), function: e('function'), catch: e('catch'), for: e('for'), switch: e('switch'), case: e('case'), default: e('default'), in: i, typeof: i, instanceof: i, true: o, false: o, null: o, undefined: o, NaN: o, Infinity: o, this: e('this'), class: e('class'), super: e('atom'), yield: n, export: e('export'), import: e('import'), extends: n, await: n,
          };
        }()); const d = /[+\-*&%=<>!?|~^@]/; const p = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/; function m(e) { let t; let r = !1; let n = !1; while ((t = e.next()) != null) { if (!r) { if (t == '/' && !n) return; t == '[' ? n = !0 : n && t == ']' && (n = !1); }r = !r && t == '\\'; } } function v(e, t, r) { return n = e, a = r, t; } function k(e, t) { const r = e.next(); if (r == '"' || r == "'") return t.tokenize = y(r), t.tokenize(e, t); if (r == '.' && e.match(/^\d+(?:[eE][+\-]?\d+)?/)) return v('number', 'number'); if (r == '.' && e.match('..')) return v('spread', 'meta'); if (/[\[\]{}\(\),;\:\.]/.test(r)) return v(r); if (r == '=' && e.eat('>')) return v('=>', 'operator'); if (r == '0' && e.match(/^(?:x[\da-f]+|o[0-7]+|b[01]+)n?/i)) return v('number', 'number'); if (/\d/.test(r)) return e.match(/^\d*(?:n|(?:\.\d*)?(?:[eE][+\-]?\d+)?)?/), v('number', 'number'); if (r == '/') return e.eat('*') ? (t.tokenize = w, w(e, t)) : e.eat('/') ? (e.skipToEnd(), v('comment', 'comment')) : Ze(e, t, 1) ? (m(e), e.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), v('regexp', 'string-2')) : (e.eat('='), v('operator', 'operator', e.current())); if (r == '`') return t.tokenize = h, h(e, t); if (r == '#') return e.skipToEnd(), v('error', 'error'); if (d.test(r)) return r == '>' && t.lexical && t.lexical.type == '>' || (e.eat('=') ? r != '!' && r != '=' || e.eat('=') : /[<>*+\-]/.test(r) && (e.eat(r), r == '>' && e.eat(r))), v('operator', 'operator', e.current()); if (l.test(r)) { e.eatWhile(l); const n = e.current(); if (t.lastType != '.') { if (f.propertyIsEnumerable(n)) { const a = f[n]; return v(a.type, a.style, n); } if (n == 'async' && e.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, !1)) return v('async', 'keyword', n); } return v('variable', 'variable', n); } } function y(e) { return function (t, r) { let n; let a = !1; if (c && t.peek() == '@' && t.match(p)) return r.tokenize = k, v('jsonld-keyword', 'meta'); while ((n = t.next()) != null) { if (n == e && !a) break; a = !a && n == '\\'; } return a || (r.tokenize = k), v('string', 'string'); }; } function w(e, t) { let r; let n = !1; while (r = e.next()) { if (r == '/' && n) { t.tokenize = k; break; }n = r == '*'; } return v('comment', 'comment'); } function h(e, t) { let r; let n = !1; while ((r = e.next()) != null) { if (!n && (r == '`' || r == '$' && e.eat('{'))) { t.tokenize = k; break; }n = !n && r == '\\'; } return v('quasi', 'string-2', e.current()); } const b = '([{}])'; function x(e, t) { t.fatArrowAt && (t.fatArrowAt = null); let r = e.string.indexOf('=>', e.start); if (!(r < 0)) { if (u) { const n = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(e.string.slice(e.start, r)); n && (r = n.index); } for (var a = 0, i = !1, o = r - 1; o >= 0; --o) { const c = e.string.charAt(o); const s = b.indexOf(c); if (s >= 0 && s < 3) { if (!a) { ++o; break; } if (--a == 0) { c == '(' && (i = !0); break; } } else if (s >= 3 && s < 6)++a; else if (l.test(c))i = !0; else { if (/["'\/]/.test(c)) return; if (i && !a) { ++o; break; } } }i && !a && (t.fatArrowAt = o); } } const g = {
          atom: !0, number: !0, variable: !0, string: !0, regexp: !0, this: !0, 'jsonld-keyword': !0,
        }; function j(e, t, r, n, a, i) { this.indented = e, this.column = t, this.type = r, this.prev = a, this.info = i, n != null && (this.align = n); } function M(e, t) { for (var r = e.localVars; r; r = r.next) if (r.name == t) return !0; for (let n = e.context; n; n = n.prev) for (r = n.vars; r; r = r.next) if (r.name == t) return !0; } function V(e, t, r, n, a) { const i = e.cc; E.state = e, E.stream = a, E.marked = null, E.cc = i, E.style = t, e.lexical.hasOwnProperty('align') || (e.lexical.align = !0); while (1) { const o = i.length ? i.pop() : s ? D : H; if (o(r, n)) { while (i.length && i[i.length - 1].lex)i.pop()(); return E.marked ? E.marked : r == 'variable' && M(e, n) ? 'variable-2' : t; } } } var E = {
          state: null, column: null, marked: null, cc: null,
        }; function A() { for (let e = arguments.length - 1; e >= 0; e--)E.cc.push(arguments[e]); } function z() { return A.apply(null, arguments), !0; } function I(e, t) { for (let r = t; r; r = r.next) if (r.name == e) return !0; return !1; } function C(e) { const t = E.state; if (E.marked = 'def', t.context) if (t.lexical.info == 'var' && t.context && t.context.block) { const n = T(e, t.context); if (n != null) return void (t.context = n); } else if (!I(e, t.localVars)) return void (t.localVars = new S(e, t.localVars)); r.globalVars && !I(e, t.globalVars) && (t.globalVars = new S(e, t.globalVars)); } function T(e, t) { if (t) { if (t.block) { const r = T(e, t.prev); return r ? r == t.prev ? t : new O(r, t.vars, !0) : null; } return I(e, t.vars) ? t : new O(t.prev, new S(e, t.vars), !1); } return null; } function $(e) { return e == 'public' || e == 'private' || e == 'protected' || e == 'abstract' || e == 'readonly'; } function O(e, t, r) { this.prev = e, this.vars = t, this.block = r; } function S(e, t) { this.name = e, this.next = t; } const _ = new S('this', new S('arguments', null)); function q() { E.state.context = new O(E.state.context, E.state.localVars, !1), E.state.localVars = _; } function J() { E.state.context = new O(E.state.context, E.state.localVars, !0), E.state.localVars = null; } function N() { E.state.localVars = E.state.context.vars, E.state.context = E.state.context.prev; } function P(e, t) { const r = function () { const r = E.state; let n = r.indented; if (r.lexical.type == 'stat')n = r.lexical.indented; else for (let a = r.lexical; a && a.type == ')' && a.align; a = a.prev)n = a.indented; r.lexical = new j(n, E.stream.column(), e, null, r.lexical, t); }; return r.lex = !0, r; } function B() { const e = E.state; e.lexical.prev && (e.lexical.type == ')' && (e.indented = e.lexical.indented), e.lexical = e.lexical.prev); } function U(e) { function t(r) { return r == e ? z() : e == ';' || r == '}' || r == ')' || r == ']' ? A() : z(t); } return t; } function H(e, t) { return e == 'var' ? z(P('vardef', t), je, U(';'), B) : e == 'keyword a' ? z(P('form'), G, H, B) : e == 'keyword b' ? z(P('form'), H, B) : e == 'keyword d' ? E.stream.match(/^\s*$/, !1) ? z() : z(P('stat'), L, U(';'), B) : e == 'debugger' ? z(U(';')) : e == '{' ? z(P('}'), J, fe, B, N) : e == ';' ? z() : e == 'if' ? (E.state.lexical.info == 'else' && E.state.cc[E.state.cc.length - 1] == B && E.state.cc.pop()(), z(P('form'), G, H, B, Ie)) : e == 'function' ? z(Oe) : e == 'for' ? z(P('form'), Ce, H, B) : e == 'class' || u && t == 'interface' ? (E.marked = 'keyword', z(P('form', e == 'class' ? e : t), Ne, B)) : e == 'variable' ? u && t == 'declare' ? (E.marked = 'keyword', z(H)) : u && (t == 'module' || t == 'enum' || t == 'type') && E.stream.match(/^\s*\w/, !1) ? (E.marked = 'keyword', t == 'enum' ? z(Re) : t == 'type' ? z(_e, U('operator'), ve, U(';')) : z(P('form'), Me, U('{'), P('}'), fe, B, B)) : u && t == 'namespace' ? (E.marked = 'keyword', z(P('form'), D, H, B)) : u && t == 'abstract' ? (E.marked = 'keyword', z(H)) : z(P('stat'), ae) : e == 'switch' ? z(P('form'), G, U('{'), P('}', 'switch'), J, fe, B, B, N) : e == 'case' ? z(D, U(':')) : e == 'default' ? z(U(':')) : e == 'catch' ? z(P('form'), q, W, H, B, N) : e == 'export' ? z(P('stat'), He, B) : e == 'import' ? z(P('stat'), De, B) : e == 'async' ? z(H) : t == '@' ? z(D, H) : A(P('stat'), D, U(';'), B); } function W(e) { if (e == '(') return z(qe, U(')')); } function D(e, t) { return K(e, t, !1); } function F(e, t) { return K(e, t, !0); } function G(e) { return e != '(' ? A() : z(P(')'), D, U(')'), B); } function K(e, t, r) { if (E.state.fatArrowAt == E.stream.start) { const n = r ? ee : Z; if (e == '(') return z(q, P(')'), ue(qe, ')'), B, U('=>'), n, N); if (e == 'variable') return A(q, Me, U('=>'), n, N); } const a = r ? R : Q; return g.hasOwnProperty(e) ? z(a) : e == 'function' ? z(Oe, a) : e == 'class' || u && t == 'interface' ? (E.marked = 'keyword', z(P('form'), Je, B)) : e == 'keyword c' || e == 'async' ? z(r ? F : D) : e == '(' ? z(P(')'), L, U(')'), B, a) : e == 'operator' || e == 'spread' ? z(r ? F : D) : e == '[' ? z(P(']'), Qe, B, a) : e == '{' ? le(oe, '}', null, a) : e == 'quasi' ? A(X, a) : e == 'new' ? z(te(r)) : e == 'import' ? z(D) : z(); } function L(e) { return e.match(/[;\}\)\],]/) ? A() : A(D); } function Q(e, t) { return e == ',' ? z(D) : R(e, t, !1); } function R(e, t, r) { const n = r == 0 ? Q : R; const a = r == 0 ? D : F; return e == '=>' ? z(q, r ? ee : Z, N) : e == 'operator' ? /\+\+|--/.test(t) || u && t == '!' ? z(n) : u && t == '<' && E.stream.match(/^([^>]|<.*?>)*>\s*\(/, !1) ? z(P('>'), ue(ve, '>'), B, n) : t == '?' ? z(D, U(':'), a) : z(a) : e == 'quasi' ? A(X, n) : e != ';' ? e == '(' ? le(F, ')', 'call', n) : e == '.' ? z(ie, n) : e == '[' ? z(P(']'), L, U(']'), B, n) : u && t == 'as' ? (E.marked = 'keyword', z(ve, n)) : e == 'regexp' ? (E.state.lastType = E.marked = 'operator', E.stream.backUp(E.stream.pos - E.stream.start - 1), z(a)) : void 0 : void 0; } function X(e, t) { return e != 'quasi' ? A() : t.slice(t.length - 2) != '${' ? z(X) : z(D, Y); } function Y(e) { if (e == '}') return E.marked = 'string-2', E.state.tokenize = h, z(X); } function Z(e) { return x(E.stream, E.state), A(e == '{' ? H : D); } function ee(e) { return x(E.stream, E.state), A(e == '{' ? H : F); } function te(e) { return function (t) { return t == '.' ? z(e ? ne : re) : t == 'variable' && u ? z(be, e ? R : Q) : A(e ? F : D); }; } function re(e, t) { if (t == 'target') return E.marked = 'keyword', z(Q); } function ne(e, t) { if (t == 'target') return E.marked = 'keyword', z(R); } function ae(e) { return e == ':' ? z(B, H) : A(Q, U(';'), B); } function ie(e) { if (e == 'variable') return E.marked = 'property', z(); } function oe(e, t) { return e == 'async' ? (E.marked = 'property', z(oe)) : e == 'variable' || E.style == 'keyword' ? (E.marked = 'property', t == 'get' || t == 'set' ? z(ce) : (u && E.state.fatArrowAt == E.stream.start && (r = E.stream.match(/^\s*:\s*/, !1)) && (E.state.fatArrowAt = E.stream.pos + r[0].length), z(se))) : e == 'number' || e == 'string' ? (E.marked = c ? 'property' : `${E.style} property`, z(se)) : e == 'jsonld-keyword' ? z(se) : u && $(t) ? (E.marked = 'keyword', z(oe)) : e == '[' ? z(D, de, U(']'), se) : e == 'spread' ? z(F, se) : t == '*' ? (E.marked = 'keyword', z(oe)) : e == ':' ? A(se) : void 0; let r; } function ce(e) { return e != 'variable' ? A(se) : (E.marked = 'property', z(Oe)); } function se(e) { return e == ':' ? z(F) : e == '(' ? A(Oe) : void 0; } function ue(e, t, r) { function n(a, i) { if (r ? r.indexOf(a) > -1 : a == ',') { const o = E.state.lexical; return o.info == 'call' && (o.pos = (o.pos || 0) + 1), z((r, n) => (r == t || n == t ? A() : A(e)), n); } return a == t || i == t ? z() : r && r.indexOf(';') > -1 ? A(e) : z(U(t)); } return function (r, a) { return r == t || a == t ? z() : A(e, n); }; } function le(e, t, r) { for (let n = 3; n < arguments.length; n++)E.cc.push(arguments[n]); return z(P(t, r), ue(e, t), B); } function fe(e) { return e == '}' ? z() : A(H, fe); } function de(e, t) { if (u) { if (e == ':' || t == 'in') return z(ve); if (t == '?') return z(de); } } function pe(e) { if (u && e == ':') return E.stream.match(/^\s*\w+\s+is\b/, !1) ? z(D, me, ve) : z(ve); } function me(e, t) { if (t == 'is') return E.marked = 'keyword', z(); } function ve(e, t) { return t == 'keyof' || t == 'typeof' || t == 'infer' ? (E.marked = 'keyword', z(t == 'typeof' ? F : ve)) : e == 'variable' || t == 'void' ? (E.marked = 'type', z(he)) : t == '|' || t == '&' ? z(ve) : e == 'string' || e == 'number' || e == 'atom' ? z(he) : e == '[' ? z(P(']'), ue(ve, ']', ','), B, he) : e == '{' ? z(P('}'), ue(ye, '}', ',;'), B, he) : e == '(' ? z(ue(we, ')'), ke, he) : e == '<' ? z(ue(ve, '>'), ve) : void 0; } function ke(e) { if (e == '=>') return z(ve); } function ye(e, t) { return e == 'variable' || E.style == 'keyword' ? (E.marked = 'property', z(ye)) : t == '?' || e == 'number' || e == 'string' ? z(ye) : e == ':' ? z(ve) : e == '[' ? z(U('variable'), de, U(']'), ye) : e == '(' ? A(Se, ye) : void 0; } function we(e, t) { return e == 'variable' && E.stream.match(/^\s*[?:]/, !1) || t == '?' ? z(we) : e == ':' ? z(ve) : e == 'spread' ? z(we) : A(ve); } function he(e, t) { return t == '<' ? z(P('>'), ue(ve, '>'), B, he) : t == '|' || e == '.' || t == '&' ? z(ve) : e == '[' ? z(ve, U(']'), he) : t == 'extends' || t == 'implements' ? (E.marked = 'keyword', z(ve)) : t == '?' ? z(ve, U(':'), ve) : void 0; } function be(e, t) { if (t == '<') return z(P('>'), ue(ve, '>'), B, he); } function xe() { return A(ve, ge); } function ge(e, t) { if (t == '=') return z(ve); } function je(e, t) { return t == 'enum' ? (E.marked = 'keyword', z(Re)) : A(Me, de, Ae, ze); } function Me(e, t) { return u && $(t) ? (E.marked = 'keyword', z(Me)) : e == 'variable' ? (C(t), z()) : e == 'spread' ? z(Me) : e == '[' ? le(Ee, ']') : e == '{' ? le(Ve, '}') : void 0; } function Ve(e, t) { return e != 'variable' || E.stream.match(/^\s*:/, !1) ? (e == 'variable' && (E.marked = 'property'), e == 'spread' ? z(Me) : e == '}' ? A() : e == '[' ? z(D, U(']'), U(':'), Ve) : z(U(':'), Me, Ae)) : (C(t), z(Ae)); } function Ee() { return A(Me, Ae); } function Ae(e, t) { if (t == '=') return z(F); } function ze(e) { if (e == ',') return z(je); } function Ie(e, t) { if (e == 'keyword b' && t == 'else') return z(P('form', 'else'), H, B); } function Ce(e, t) { return t == 'await' ? z(Ce) : e == '(' ? z(P(')'), Te, B) : void 0; } function Te(e) { return e == 'var' ? z(je, $e) : e == 'variable' ? z($e) : A($e); } function $e(e, t) { return e == ')' ? z() : e == ';' ? z($e) : t == 'in' || t == 'of' ? (E.marked = 'keyword', z(D, $e)) : A(D, $e); } function Oe(e, t) { return t == '*' ? (E.marked = 'keyword', z(Oe)) : e == 'variable' ? (C(t), z(Oe)) : e == '(' ? z(q, P(')'), ue(qe, ')'), B, pe, H, N) : u && t == '<' ? z(P('>'), ue(xe, '>'), B, Oe) : void 0; } function Se(e, t) { return t == '*' ? (E.marked = 'keyword', z(Se)) : e == 'variable' ? (C(t), z(Se)) : e == '(' ? z(q, P(')'), ue(qe, ')'), B, pe, N) : u && t == '<' ? z(P('>'), ue(xe, '>'), B, Se) : void 0; } function _e(e, t) { return e == 'keyword' || e == 'variable' ? (E.marked = 'type', z(_e)) : t == '<' ? z(P('>'), ue(xe, '>'), B) : void 0; } function qe(e, t) { return t == '@' && z(D, qe), e == 'spread' ? z(qe) : u && $(t) ? (E.marked = 'keyword', z(qe)) : u && e == 'this' ? z(de, Ae) : A(Me, de, Ae); } function Je(e, t) { return e == 'variable' ? Ne(e, t) : Pe(e, t); } function Ne(e, t) { if (e == 'variable') return C(t), z(Pe); } function Pe(e, t) { return t == '<' ? z(P('>'), ue(xe, '>'), B, Pe) : t == 'extends' || t == 'implements' || u && e == ',' ? (t == 'implements' && (E.marked = 'keyword'), z(u ? ve : D, Pe)) : e == '{' ? z(P('}'), Be, B) : void 0; } function Be(e, t) { return e == 'async' || e == 'variable' && (t == 'static' || t == 'get' || t == 'set' || u && $(t)) && E.stream.match(/^\s+[\w$\xa1-\uffff]/, !1) ? (E.marked = 'keyword', z(Be)) : e == 'variable' || E.style == 'keyword' ? (E.marked = 'property', z(u ? Ue : Oe, Be)) : e == 'number' || e == 'string' ? z(u ? Ue : Oe, Be) : e == '[' ? z(D, de, U(']'), u ? Ue : Oe, Be) : t == '*' ? (E.marked = 'keyword', z(Be)) : u && e == '(' ? A(Se, Be) : e == ';' || e == ',' ? z(Be) : e == '}' ? z() : t == '@' ? z(D, Be) : void 0; } function Ue(e, t) { if (t == '?') return z(Ue); if (e == ':') return z(ve, Ae); if (t == '=') return z(F); const r = E.state.lexical.prev; const n = r && r.info == 'interface'; return A(n ? Se : Oe); } function He(e, t) { return t == '*' ? (E.marked = 'keyword', z(Le, U(';'))) : t == 'default' ? (E.marked = 'keyword', z(D, U(';'))) : e == '{' ? z(ue(We, '}'), Le, U(';')) : A(H); } function We(e, t) { return t == 'as' ? (E.marked = 'keyword', z(U('variable'))) : e == 'variable' ? A(F, We) : void 0; } function De(e) { return e == 'string' ? z() : e == '(' ? A(D) : A(Fe, Ge, Le); } function Fe(e, t) { return e == '{' ? le(Fe, '}') : (e == 'variable' && C(t), t == '*' && (E.marked = 'keyword'), z(Ke)); } function Ge(e) { if (e == ',') return z(Fe, Ge); } function Ke(e, t) { if (t == 'as') return E.marked = 'keyword', z(Fe); } function Le(e, t) { if (t == 'from') return E.marked = 'keyword', z(D); } function Qe(e) { return e == ']' ? z() : A(ue(F, ']')); } function Re() { return A(P('form'), Me, U('{'), P('}'), ue(Xe, '}'), B, B); } function Xe() { return A(Me, Ae); } function Ye(e, t) { return e.lastType == 'operator' || e.lastType == ',' || d.test(t.charAt(0)) || /[,.]/.test(t.charAt(0)); } function Ze(e, t, r) { return t.tokenize == k && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(t.lastType) || t.lastType == 'quasi' && /\{\s*$/.test(e.string.slice(0, e.pos - (r || 0))); } return N.lex = !0, B.lex = !0, {
          startState(e) {
            const t = {
              tokenize: k, lastType: 'sof', cc: [], lexical: new j((e || 0) - i, 0, 'block', !1), localVars: r.localVars, context: r.localVars && new O(null, null, !1), indented: e || 0,
            }; return r.globalVars && typeof r.globalVars === 'object' && (t.globalVars = r.globalVars), t;
          },
          token(e, t) { if (e.sol() && (t.lexical.hasOwnProperty('align') || (t.lexical.align = !1), t.indented = e.indentation(), x(e, t)), t.tokenize != w && e.eatSpace()) return null; const r = t.tokenize(e, t); return n == 'comment' ? r : (t.lastType = n != 'operator' || a != '++' && a != '--' ? n : 'incdec', V(t, r, n, a, e)); },
          indent(t, n) { if (t.tokenize == w) return e.Pass; if (t.tokenize != k) return 0; let a; const c = n && n.charAt(0); let s = t.lexical; if (!/^\s*else\b/.test(n)) for (let u = t.cc.length - 1; u >= 0; --u) { const l = t.cc[u]; if (l == B)s = s.prev; else if (l != Ie) break; } while ((s.type == 'stat' || s.type == 'form') && (c == '}' || (a = t.cc[t.cc.length - 1]) && (a == Q || a == R) && !/^[,\.=+\-*:?[\(]/.test(n)))s = s.prev; o && s.type == ')' && s.prev.type == 'stat' && (s = s.prev); const f = s.type; const d = c == f; return f == 'vardef' ? s.indented + (t.lastType == 'operator' || t.lastType == ',' ? s.info.length + 1 : 0) : f == 'form' && c == '{' ? s.indented : f == 'form' ? s.indented + i : f == 'stat' ? s.indented + (Ye(t, n) ? o || i : 0) : s.info != 'switch' || d || r.doubleIndentSwitch == 0 ? s.align ? s.column + (d ? 0 : 1) : s.indented + (d ? 0 : i) : s.indented + (/^(?:case|default)\b/.test(n) ? i : 2 * i); },
          electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
          blockCommentStart: s ? null : '/*',
          blockCommentEnd: s ? null : '*/',
          blockCommentContinue: s ? null : ' * ',
          lineComment: s ? null : '//',
          fold: 'brace',
          closeBrackets: "()[]{}''\"\"``",
          helperType: s ? 'json' : 'javascript',
          jsonldMode: c,
          jsonMode: s,
          expressionAllowed: Ze,
          skipExpression(e) { const t = e.cc[e.cc.length - 1]; t != D && t != F || e.cc.pop(); },
        };
      }), e.registerHelper('wordChars', 'javascript', /[\w$]/), e.defineMIME('text/javascript', 'javascript'), e.defineMIME('text/ecmascript', 'javascript'), e.defineMIME('application/javascript', 'javascript'), e.defineMIME('application/x-javascript', 'javascript'), e.defineMIME('application/ecmascript', 'javascript'), e.defineMIME('application/json', { name: 'javascript', json: !0 }), e.defineMIME('application/x-json', { name: 'javascript', json: !0 }), e.defineMIME('application/ld+json', { name: 'javascript', jsonld: !0 }), e.defineMIME('text/typescript', { name: 'javascript', typescript: !0 }), e.defineMIME('application/typescript', { name: 'javascript', typescript: !0 });
    }));
  },
}]);
