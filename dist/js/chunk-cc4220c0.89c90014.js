(window.webpackJsonp = window.webpackJsonp || []).push([['chunk-cc4220c0'], {
  '11e9': function (t, e, i) { const s = i('52a7'); const o = i('4630'); const n = i('6821'); const r = i('6a99'); const a = i('69a8'); const h = i('c69a'); const l = Object.getOwnPropertyDescriptor; e.f = i('9e1e') ? l : function (t, e) { if (t = n(t), e = r(e, !0), h) try { return l(t, e); } catch (i) {} if (a(t, e)) return o(!s.f.call(t, e), t[e]); }; },
  '162e': function (t, e, i) {
    i.r(e); const s = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('div', { staticClass: 'wrapper app-wrapper' }, [i('app-drawer'), i('app-bar'), i('app-content')], 1); }; const o = []; const n = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('mu-drawer', { staticClass: 'app-drawer', attrs: { open: t.open, docked: t.docked }, on: { 'update:open': function (e) { t.open = e; } } }, [i('scroll-container', { attrs: { data: t.routes } }, [i('mu-list', { attrs: { 'toggle-nested': '', value: t.value }, on: { change: t.onChange } }, [t._l(t.routes, e => [e.cached && !e.meta.hidden ? i('keep-alive', { key: e.path }, [i('app-drawer-item', { attrs: { item: e, defaultOpen: e.meta && void 0 !== e.meta.defaultOpen } })], 1) : e.meta.hidden ? t._e() : i('app-drawer-item', { key: e.path, attrs: { item: e, defaultOpen: e.meta && void 0 !== e.meta.defaultOpen } })])], 2)], 1)], 1); }; const r = []; const a = (i('7f7f'), function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('div', { ref: 'scroll-wrapper', staticClass: 'row-item col-item' }, [t._t('default')], 2); }); const h = []; i('c5f6');
    /*!
 * better-normal-scroll v1.15.2
 * (c) 2016-2019 ustbhuangyi
 * Released under the MIT License.
 */
    function l(t, e) { for (;e + 1 < t.length; e++)t[e] = t[e + 1]; t.pop(); } const c = (function () { function t(t, e) { const i = []; let s = !0; let o = !1; let n = void 0; try { for (var r, a = t[Symbol.iterator](); !(s = (r = a.next()).done); s = !0) if (i.push(r.value), e && i.length === e) break; } catch (h) { o = !0, n = h; } finally { try { !s && a.return && a.return(); } finally { if (o) throw n; } } return i; } return function (e, i) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return t(e, i); throw new TypeError('Invalid attempt to destructure non-iterable instance'); }; }()); const p = function (t) { if (Array.isArray(t)) { for (var e = 0, i = Array(t.length); e < t.length; e++)i[e] = t[e]; return i; } return Array.from(t); }; function u(t) { t.prototype.on = function (t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this; this._events[t] || (this._events[t] = []), this._events[t].push([e, i]); }, t.prototype.once = function (t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this; function s() { this.off(t, s), e.apply(i, arguments); }s.fn = e, this.on(t, s); }, t.prototype.off = function (t, e) { const i = this._events[t]; if (i) { let s = i.length; while (s--)(i[s][0] === e || i[s][0] && i[s][0].fn === e) && l(i, s); } }, t.prototype.trigger = function (t) { const e = this._events[t]; if (e) for (let i = e.length, s = [].concat(p(e)), o = 0; o < i; o++) { const n = s[o]; const r = c(n, 2); const a = r[0]; const h = r[1]; a && a.apply(h, [].slice.call(arguments, 1)); } }; } const d = typeof window !== 'undefined'; const m = d && navigator.userAgent.toLowerCase(); const f = m && /wechatdevtools/.test(m); const g = m && m.indexOf('android') > 0; function v() { return window.performance && window.performance.now ? window.performance.now() + window.performance.timing.navigationStart : +new Date(); } function y(t) { for (var e = arguments.length, i = Array(e > 1 ? e - 1 : 0), s = 1; s < e; s++)i[s - 1] = arguments[s]; for (let o = 0; o < i.length; o++) { const n = i[o]; for (const r in n)t[r] = n[r]; } return t; } function b(t) { return void 0 === t || t === null; } function w(t, e) { return Math.sqrt(t * t + e * e); } const x = d && document.createElement('div').style; const S = (function () {
      if (!d) return !1; const t = {
        standard: 'transform', webkit: 'webkitTransform', Moz: 'MozTransform', O: 'OTransform', ms: 'msTransform',
      }; for (const e in t) if (void 0 !== x[t[e]]) return e; return !1;
    }()); function T(t) { return !1 !== S && (S === 'standard' ? t === 'transitionEnd' ? 'transitionend' : t : S + t.charAt(0).toUpperCase() + t.substr(1)); } function _(t, e, i, s) { t.addEventListener(e, i, { passive: !1, capture: !!s }); } function A(t, e, i, s) { t.removeEventListener(e, i, { passive: !1, capture: !!s }); } function E(t) { let e = 0; let i = 0; while (t)e -= t.offsetLeft, i -= t.offsetTop, t = t.offsetParent; return { left: e, top: i }; } function Y(t) { const e = t.getBoundingClientRect(); return { left: -(e.left + window.pageXOffset), top: -(e.top + window.pageYOffset) }; } const X = S && S !== 'standard' ? `-${S.toLowerCase()}-` : ''; const M = T('transform');
    const P = T('transition'); const D = d && T('perspective') in x;
    const I = d && ('ontouchstart' in window || f);
    const k = !1 !== M;
    const C = d && P in x;
    const O = {
      transform: M, transition: P, transitionTimingFunction: T('transitionTimingFunction'), transitionDuration: T('transitionDuration'), transitionDelay: T('transitionDelay'), transformOrigin: T('transformOrigin'), transitionEnd: T('transitionEnd'),
    };
    const z = 1;
    const H = 2;
    const W = {
      touchstart: z, touchmove: z, touchend: z, mousedown: H, mousemove: H, mouseup: H,
    }; function F(t) {
      if (t instanceof window.SVGElement) {
        const e = t.getBoundingClientRect(); return {
          top: e.top, left: e.left, width: e.width, height: e.height,
        };
      } return {
        top: t.offsetTop, left: t.offsetLeft, width: t.offsetWidth, height: t.offsetHeight,
      };
    } function L(t, e) { for (const i in e) if (e[i].test(t[i])) return !0; return !1; } function N(t, e) { const i = document.createEvent('Event'); i.initEvent(e, !0, !0), i.pageX = t.pageX, i.pageY = t.pageY, t.target.dispatchEvent(i); } function R(t) {
      const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'click'; let
        i = void 0; t.type === 'mouseup' || t.type === 'mousecancel' ? i = t : t.type !== 'touchend' && t.type !== 'touchcancel' || (i = t.changedTouches[0]); const s = {}; i && (s.screenX = i.screenX || 0, s.screenY = i.screenY || 0, s.clientX = i.clientX || 0, s.clientY = i.clientY || 0); let o = void 0; const n = !0; const r = !0; if (typeof MouseEvent !== 'undefined') try { o = new MouseEvent(e, y({ bubbles: n, cancelable: r }, s)); } catch (t) { a(); } else a(); function a() { o = document.createEvent('Event'), o.initEvent(e, n, r), y(o, s); }o.forwardedTouchEvent = !0, o._constructed = !0, t.target.dispatchEvent(o);
    } function B(t) { R(t, 'dblclick'); } function U(t, e) { e.firstChild ? $(t, e.firstChild) : e.appendChild(t); } function $(t, e) { e.parentNode.insertBefore(t, e); } function V(t, e) { t.removeChild(e); } const q = {
      startX: 0, startY: 0, scrollX: !1, scrollY: !0, freeScroll: !1, directionLockThreshold: 5, eventPassthrough: '', click: !1, tap: !1, bounce: !0, bounceTime: 800, momentum: !0, momentumLimitTime: 300, momentumLimitDistance: 15, swipeTime: 2500, swipeBounceTime: 500, deceleration: 0.0015, flickLimitTime: 200, flickLimitDistance: 100, resizePolling: 60, probeType: 0, preventDefault: !0, preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|AUDIO)$/ }, HWCompositing: !0, useTransition: !0, useTransform: !0, bindToWrapper: !1, disableMouse: I, disableTouch: !I, observeDOM: !0, autoBlur: !0, wheel: !1, snap: !1, scrollbar: !1, pullDownRefresh: !1, pullUpLoad: !1, mouseWheel: !1, stopPropagation: !1, zoom: !1, infinity: !1, dblclick: !1,
    }; function Q(t) { t.prototype._init = function (t) { this._handleOptions(t), this._events = {}, this.x = 0, this.y = 0, this.directionX = 0, this.directionY = 0, this.setScale(1), this._addDOMEvents(), this._initExtFeatures(), this._watchTransition(), this.options.observeDOM && this._initDOMObserver(), this.options.autoBlur && this._handleAutoBlur(), this.refresh(), this.options.snap || this.scrollTo(this.options.startX, this.options.startY), this.enable(); }, t.prototype.setScale = function (t) { this.lastScale = b(this.scale) ? t : this.scale, this.scale = t; }, t.prototype._handleOptions = function (t) { this.options = y({}, q, t), this.translateZ = this.options.HWCompositing && D ? ' translateZ(0)' : '', this.options.useTransition = this.options.useTransition && C, this.options.useTransform = this.options.useTransform && k, this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault, this.options.scrollX = this.options.eventPassthrough !== 'horizontal' && this.options.scrollX, this.options.scrollY = this.options.eventPassthrough !== 'vertical' && this.options.scrollY, this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough, this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold, !0 === this.options.tap && (this.options.tap = 'tap'); }, t.prototype._addDOMEvents = function () { const t = _; this._handleDOMEvents(t); }, t.prototype._removeDOMEvents = function () { const t = A; this._handleDOMEvents(t); }, t.prototype._handleDOMEvents = function (t) { const e = this.options.bindToWrapper ? this.wrapper : window; t(window, 'orientationchange', this), t(window, 'resize', this), this.options.click && t(this.wrapper, 'click', this, !0), this.options.disableMouse || (t(this.wrapper, 'mousedown', this), t(e, 'mousemove', this), t(e, 'mousecancel', this), t(e, 'mouseup', this)), I && !this.options.disableTouch && (t(this.wrapper, 'touchstart', this), t(e, 'touchmove', this), t(e, 'touchcancel', this), t(e, 'touchend', this)), t(this.scroller, O.transitionEnd, this); }, t.prototype._initExtFeatures = function () { this.options.snap && this._initSnap(), this.options.scrollbar && this._initScrollbar(), this.options.pullUpLoad && this._initPullUp(), this.options.pullDownRefresh && this._initPullDown(), this.options.wheel && this._initWheel(), this.options.mouseWheel && this._initMouseWheel(), this.options.zoom && this._initZoom(), this.options.infinity && this._initInfinite(); }, t.prototype._watchTransition = function () { if (typeof Object.defineProperty === 'function') { const t = this; let e = !1; const i = this.options.useTransition ? 'isInTransition' : 'isAnimating'; Object.defineProperty(this, i, { get() { return e; }, set(i) { e = i; for (let s = t.scroller.children.length ? t.scroller.children : [t.scroller], o = e && !t.pulling ? 'none' : 'auto', n = 0; n < s.length; n++)s[n].style.pointerEvents = o; } }); } }, t.prototype._handleAutoBlur = function () { this.on('scrollStart', () => { const t = document.activeElement; !t || t.tagName !== 'INPUT' && t.tagName !== 'TEXTAREA' || t.blur(); }); }, t.prototype._initDOMObserver = function () { const t = this; if (typeof MutationObserver !== 'undefined') { let e = void 0; const i = new MutationObserver(((i) => { if (!t._shouldNotRefresh()) { for (var s = !1, o = !1, n = 0; n < i.length; n++) { const r = i[n]; if (r.type !== 'attributes') { s = !0; break; } if (r.target !== t.scroller) { o = !0; break; } }s ? t.refresh() : o && (clearTimeout(e), e = setTimeout(() => { t._shouldNotRefresh() || t.refresh(); }, 60)); } })); const s = { attributes: !0, childList: !0, subtree: !0 }; i.observe(this.scroller, s), this.on('destroy', () => { i.disconnect(); }); } else this._checkDOMUpdate(); }, t.prototype._shouldNotRefresh = function () { const t = this.x > this.minScrollX || this.x < this.maxScrollX || this.y > this.minScrollY || this.y < this.maxScrollY; return this.isInTransition || this.stopFromTransition || t; }, t.prototype._checkDOMUpdate = function () { let t = F(this.scroller); let e = t.width; let i = t.height; function s() { if (!this.destroyed) { t = F(this.scroller); const s = t.width; const n = t.height; e === s && i === n || this.refresh(), e = s, i = n, o.call(this); } } function o() { const t = this; setTimeout(() => { s.call(t); }, 1e3); }o.call(this); }, t.prototype.handleEvent = function (t) { switch (t.type) { case 'touchstart': case 'mousedown': this._start(t), this.options.zoom && t.touches && t.touches.length > 1 && this._zoomStart(t); break; case 'touchmove': case 'mousemove': this.options.zoom && t.touches && t.touches.length > 1 ? this._zoom(t) : this._move(t); break; case 'touchend': case 'mouseup': case 'touchcancel': case 'mousecancel': this.scaled ? this._zoomEnd(t) : this._end(t); break; case 'orientationchange': case 'resize': this._resize(); break; case 'transitionend': case 'webkitTransitionEnd': case 'oTransitionEnd': case 'MSTransitionEnd': this._transitionEnd(t); break; case 'click': this.enabled && !t._constructed && (L(t.target, this.options.preventDefaultException) || (t.preventDefault(), t.stopPropagation())); break; case 'wheel': case 'DOMMouseScroll': case 'mousewheel': this._onMouseWheel(t); break; } }, t.prototype.refresh = function () { const t = window.getComputedStyle(this.wrapper, null).position === 'static'; const e = F(this.wrapper); this.wrapperWidth = e.width, this.wrapperHeight = e.height; const i = F(this.scroller); this.scrollerWidth = Math.round(i.width * this.scale), this.scrollerHeight = Math.round(i.height * this.scale), this.relativeX = i.left, this.relativeY = i.top, t && (this.relativeX -= e.left, this.relativeY -= e.top), this.minScrollX = 0, this.minScrollY = 0; const s = this.options.wheel; s ? (this.items = this.scroller.children, this._checkWheelAllDisabled(), this.options.itemHeight = this.itemHeight = this.items.length ? this.scrollerHeight / this.items.length : 0, void 0 === this.selectedIndex && (this.selectedIndex = s.selectedIndex || 0), this.options.startY = -this.selectedIndex * this.itemHeight, this.maxScrollX = 0, this.maxScrollY = -this.itemHeight * (this.items.length - 1)) : (this.maxScrollX = this.wrapperWidth - this.scrollerWidth, this.options.infinity || (this.maxScrollY = this.wrapperHeight - this.scrollerHeight), this.maxScrollX < 0 ? (this.maxScrollX -= this.relativeX, this.minScrollX = -this.relativeX) : this.scale > 1 && (this.maxScrollX = this.maxScrollX / 2 - this.relativeX, this.minScrollX = this.maxScrollX), this.maxScrollY < 0 ? (this.maxScrollY -= this.relativeY, this.minScrollY = -this.relativeY) : this.scale > 1 && (this.maxScrollY = this.maxScrollY / 2 - this.relativeY, this.minScrollY = this.maxScrollY)), this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < this.minScrollX, this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < this.minScrollY, this.hasHorizontalScroll || (this.maxScrollX = this.minScrollX, this.scrollerWidth = this.wrapperWidth), this.hasVerticalScroll || (this.maxScrollY = this.minScrollY, this.scrollerHeight = this.wrapperHeight), this.endTime = 0, this.directionX = 0, this.directionY = 0, this.wrapperOffset = E(this.wrapper), this.trigger('refresh'), !this.scaled && this.resetPosition(); }, t.prototype.enable = function () { this.enabled = !0; }, t.prototype.disable = function () { this.enabled = !1; }; } const j = { swipe: { style: 'cubic-bezier(0.23, 1, 0.32, 1)', fn(t) { return 1 + --t * t * t * t * t; } }, swipeBounce: { style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)', fn(t) { return t * (2 - t); } }, bounce: { style: 'cubic-bezier(0.165, 0.84, 0.44, 1)', fn(t) { return 1 - --t * t * t * t; } } }; function G(t, e, i, s, o, n, r, a) { const h = t - e; const l = Math.abs(h) / i; const c = r.deceleration; const p = r.itemHeight; const u = r.swipeBounceTime; const d = r.wheel; const m = r.swipeTime; let f = m; const g = d ? 4 : 15; let v = t + l / c * (h < 0 ? -1 : 1); return d && p && (v = a._findNearestValidWheel(v).y), v < s ? (v = n ? Math.max(s - n / 4, s - n / g * l) : s, f = u) : v > o && (v = n ? Math.min(o + n / 4, o + n / g * l) : o, f = u), { destination: Math.round(v), duration: f }; } const K = 100 / 60; function Z() {} const J = (function () { return d ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || function (t) { return window.setTimeout(t, (t.interval || K) / 2); } : Z; }()); const tt = (function () { return d ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || function (t) { window.clearTimeout(t); } : Z; }()); const et = 1; const it = -1; const st = 1; const ot = -1; const nt = 1; const rt = 3; function at(t) { console.error(`[BScroll warn]: ${t}`); } function ht(t, e) { if (!t) throw new Error(`[BScroll] ${e}`); } function lt(t) { t.prototype._start = function (t) { const e = W[t.type]; if ((e === z || t.button === 0) && !(!this.enabled || this.destroyed || this.initiated && this.initiated !== e)) { this.initiated = e, this.options.preventDefault && !L(t.target, this.options.preventDefaultException) && t.preventDefault(), this.options.stopPropagation && t.stopPropagation(), this.moved = !1, this.distX = 0, this.distY = 0, this.directionX = 0, this.directionY = 0, this.movingDirectionX = 0, this.movingDirectionY = 0, this.directionLocked = 0, this._transitionTime(), this.startTime = v(), this.options.wheel && (this.target = t.target), this.stop(); const i = t.touches ? t.touches[0] : t; this.startX = this.x, this.startY = this.y, this.absStartX = this.x, this.absStartY = this.y, this.pointX = i.pageX, this.pointY = i.pageY, this.trigger('beforeScrollStart'); } }, t.prototype._move = function (t) { if (this.enabled && !this.destroyed && W[t.type] === this.initiated) { this.options.preventDefault && t.preventDefault(), this.options.stopPropagation && t.stopPropagation(); const e = t.touches ? t.touches[0] : t; let i = e.pageX - this.pointX; let s = e.pageY - this.pointY; this.pointX = e.pageX, this.pointY = e.pageY, this.distX += i, this.distY += s; const o = Math.abs(this.distX); const n = Math.abs(this.distY); const r = v(); if (!(r - this.endTime > this.options.momentumLimitTime && !this.moved && n < this.options.momentumLimitDistance && o < this.options.momentumLimitDistance)) { if (this.directionLocked || this.options.freeScroll || (o > n + this.options.directionLockThreshold ? this.directionLocked = 'h' : n >= o + this.options.directionLockThreshold ? this.directionLocked = 'v' : this.directionLocked = 'n'), this.directionLocked === 'h') { if (this.options.eventPassthrough === 'vertical')t.preventDefault(); else if (this.options.eventPassthrough === 'horizontal') return void (this.initiated = !1); s = 0; } else if (this.directionLocked === 'v') { if (this.options.eventPassthrough === 'horizontal')t.preventDefault(); else if (this.options.eventPassthrough === 'vertical') return void (this.initiated = !1); i = 0; }i = this.hasHorizontalScroll ? i : 0, s = this.hasVerticalScroll ? s : 0, this.movingDirectionX = i > 0 ? ot : i < 0 ? st : 0, this.movingDirectionY = s > 0 ? it : s < 0 ? et : 0; let a = this.x + i; let h = this.y + s; let l = !1; let c = !1; let p = !1; let u = !1; const d = this.options.bounce; !1 !== d && (l = void 0 === d.top || d.top, c = void 0 === d.bottom || d.bottom, p = void 0 === d.left || d.left, u = void 0 === d.right || d.right), (a > this.minScrollX || a < this.maxScrollX) && (a = a > this.minScrollX && p || a < this.maxScrollX && u ? this.x + i / 3 : a > this.minScrollX ? this.minScrollX : this.maxScrollX), (h > this.minScrollY || h < this.maxScrollY) && (h = h > this.minScrollY && l || h < this.maxScrollY && c ? this.y + s / 3 : h > this.minScrollY ? this.minScrollY : this.maxScrollY), this.moved || (this.moved = !0, this.trigger('scrollStart')), this._translate(a, h), r - this.startTime > this.options.momentumLimitTime && (this.startTime = r, this.startX = this.x, this.startY = this.y, this.options.probeType === nt && this.trigger('scroll', { x: this.x, y: this.y })), this.options.probeType > nt && this.trigger('scroll', { x: this.x, y: this.y }); const m = document.documentElement.scrollLeft || window.pageXOffset || document.body.scrollLeft; const f = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop; const g = this.pointX - m; const y = this.pointY - f; (g > document.documentElement.clientWidth - this.options.momentumLimitDistance || g < this.options.momentumLimitDistance || y < this.options.momentumLimitDistance || y > document.documentElement.clientHeight - this.options.momentumLimitDistance) && this._end(t); } } }, t.prototype._end = function (t) { if (this.enabled && !this.destroyed && W[t.type] === this.initiated) { this.initiated = !1, this.options.preventDefault && !L(t.target, this.options.preventDefaultException) && t.preventDefault(), this.options.stopPropagation && t.stopPropagation(), this.trigger('touchEnd', { x: this.x, y: this.y }), this.isInTransition = !1; let e = Math.round(this.x); let i = Math.round(this.y); const s = e - this.absStartX; const o = i - this.absStartY; if (this.directionX = s > 0 ? ot : s < 0 ? st : 0, this.directionY = o > 0 ? it : o < 0 ? et : 0, !this.options.pullDownRefresh || !this._checkPullDown()) if (this._checkClick(t)) this.trigger('scrollCancel'); else if (!this.resetPosition(this.options.bounceTime, j.bounce)) { this._translate(e, i), this.endTime = v(); const n = this.endTime - this.startTime; const r = Math.abs(e - this.startX); const a = Math.abs(i - this.startY); if (this._events.flick && n < this.options.flickLimitTime && r < this.options.flickLimitDistance && a < this.options.flickLimitDistance) this.trigger('flick'); else { let h = 0; if (this.options.momentum && n < this.options.momentumLimitTime && (a > this.options.momentumLimitDistance || r > this.options.momentumLimitDistance)) { let l = !1; let c = !1; let p = !1; let u = !1; const d = this.options.bounce; !1 !== d && (l = void 0 === d.top || d.top, c = void 0 === d.bottom || d.bottom, p = void 0 === d.left || d.left, u = void 0 === d.right || d.right); const m = this.directionX === ot && p || this.directionX === st && u ? this.wrapperWidth : 0; const f = this.directionY === it && l || this.directionY === et && c ? this.wrapperHeight : 0; const g = this.hasHorizontalScroll ? G(this.x, this.startX, n, this.maxScrollX, this.minScrollX, m, this.options, this) : { destination: e, duration: 0 }; const y = this.hasVerticalScroll ? G(this.y, this.startY, n, this.maxScrollY, this.minScrollY, f, this.options, this) : { destination: i, duration: 0 }; e = g.destination, i = y.destination, h = Math.max(g.duration, y.duration), this.isInTransition = !0; } else this.options.wheel && (i = this._findNearestValidWheel(i).y, h = this.options.wheel.adjustTime || 400); let b = j.swipe; if (this.options.snap) { const w = this._nearestSnap(e, i); this.currentPage = w, h = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(e - w.x), 1e3), Math.min(Math.abs(i - w.y), 1e3)), 300), e = w.x, i = w.y, this.directionX = 0, this.directionY = 0, b = this.options.snap.easing || j.bounce; } if (e !== this.x || i !== this.y) return (e > this.minScrollX || e < this.maxScrollX || i > this.minScrollY || i < this.maxScrollY) && (b = j.swipeBounce), void this.scrollTo(e, i, h, b); this.options.wheel && (this.selectedIndex = this._findNearestValidWheel(this.y).index), this.trigger('scrollEnd', { x: this.x, y: this.y }); } } } }, t.prototype._checkClick = function (t) { const e = this.stopFromTransition && !this.pulling; if (this.stopFromTransition = !1, !this.moved) { if (this.options.wheel) { if (this.target && this.target.className === this.options.wheel.wheelWrapperClass) { const i = this._findNearestValidWheel(this.y).index; const s = Math.round((this.pointY + Y(this.wrapper).top - this.wrapperHeight / 2) / this.itemHeight); this.target = this.items[i + s]; } let o = E(this.target).top; let n = E(this.target).left; return o -= this.wrapperOffset.top, o -= Math.round(this.target.offsetHeight / 2 - this.wrapper.offsetHeight / 2) || 0, n -= this.wrapperOffset.left, n -= Math.round(this.target.offsetWidth / 2 - this.wrapper.offsetWidth / 2) || 0, o = this._findNearestValidWheel(o).y, this.scrollTo(n, o, this.options.wheel.adjustTime || 400, j.swipe), !0; } if (!e) { const r = this.options.dblclick; let a = !1; if (r && this.lastClickTime) { const h = r.delay; const l = void 0 === h ? 300 : h; v() - this.lastClickTime < l && (a = !0, B(t)); } return this.options.tap && N(t, this.options.tap), this.options.click && !L(t.target, this.options.preventDefaultException) && R(t), this.lastClickTime = a ? null : v(), !0; } return !1; } return !1; }, t.prototype._resize = function () { const t = this; this.enabled && (g && (this.wrapper.scrollTop = 0), clearTimeout(this.resizeTimeout), this.resizeTimeout = setTimeout(() => { t.refresh(); }, this.options.resizePolling)); }, t.prototype._startProbe = function () { tt(this.probeTimer), this.probeTimer = J(e); const t = this; function e() { const i = t.getComputedPosition(); t.trigger('scroll', i), t.isInTransition ? t.probeTimer = J(e) : t.trigger('scrollEnd', i); } }, t.prototype._transitionTime = function () { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; if (this.scrollerStyle[O.transitionDuration] = `${t}ms`, this.options.wheel) for (let e = 0; e < this.items.length; e++) this.items[e].style[O.transitionDuration] = `${t}ms`; if (this.indicators) for (let i = 0; i < this.indicators.length; i++) this.indicators[i].transitionTime(t); }, t.prototype._transitionTimingFunction = function (t) { if (this.scrollerStyle[O.transitionTimingFunction] = t, this.options.wheel) for (let e = 0; e < this.items.length; e++) this.items[e].style[O.transitionTimingFunction] = t; if (this.indicators) for (let i = 0; i < this.indicators.length; i++) this.indicators[i].transitionTimingFunction(t); }, t.prototype._transitionEnd = function (t) { if (t.target === this.scroller && this.isInTransition) { this._transitionTime(); const e = !this.pulling || this.movingDirectionY === et; e && !this.resetPosition(this.options.bounceTime, j.bounce) && (this.isInTransition = !1, this.options.probeType !== rt && this.trigger('scrollEnd', { x: this.x, y: this.y })); } }, t.prototype._translate = function (t, e, i) { if (ht(!b(t) && !b(e), 'Translate x or y is null or undefined.'), b(i) && (i = this.scale), this.options.useTransform ? this.scrollerStyle[O.transform] = `translate(${t}px,${e}px) scale(${i})${this.translateZ}` : (t = Math.round(t), e = Math.round(e), this.scrollerStyle.left = `${t}px`, this.scrollerStyle.top = `${e}px`), this.options.wheel) for (let s = this.options.wheel.rotate, o = void 0 === s ? 25 : s, n = 0; n < this.items.length; n++) { const r = o * (e / this.itemHeight + n); this.items[n].style[O.transform] = `rotateX(${r}deg)`; } if (this.x = t, this.y = e, this.setScale(i), this.indicators) for (let a = 0; a < this.indicators.length; a++) this.indicators[a].updatePosition(); }, t.prototype._animate = function (t, e, i, s) { const o = this; const n = this.x; const r = this.y; const a = this.lastScale; const h = this.scale; const l = v(); const c = l + i; function p() { let u = v(); if (u >= c) return o.isAnimating = !1, o._translate(t, e, h), o.trigger('scroll', { x: o.x, y: o.y }), void (o.pulling || o.resetPosition(o.options.bounceTime) || o.trigger('scrollEnd', { x: o.x, y: o.y })); u = (u - l) / i; const d = s(u); const m = (t - n) * d + n; const f = (e - r) * d + r; const g = (h - a) * d + a; o._translate(m, f, g), o.isAnimating && (o.animateTimer = J(p)), o.options.probeType === rt && o.trigger('scroll', { x: o.x, y: o.y }); } this.isAnimating = !0, tt(this.animateTimer), p(); }, t.prototype.scrollBy = function (t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; const s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : j.bounce; t = this.x + t, e = this.y + e, this.scrollTo(t, e, i, s); }, t.prototype.scrollTo = function (t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; const s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : j.bounce; const o = arguments[4]; if (this.options.wheel && (e = this._findNearestValidWheel(e).y), t !== this.x || e !== this.y) if (this.isInTransition = this.options.useTransition && i > 0 && (this.x !== t || this.y !== e), !i || this.options.useTransition) { if (this._transitionTimingFunction(s.style), this._transitionTime(i), this._translate(t, e), i && this.options.probeType === rt && this._startProbe(), !i && !o) { if (this.options.zoom) return; this.trigger('scroll', { x: t, y: e }), this._reflow = document.body.offsetHeight, this.resetPosition(this.options.bounceTime, j.bounce) || this.trigger('scrollEnd', { x: t, y: e }); } this.options.wheel && (this.selectedIndex = this._findNearestValidWheel(e).index); } else this._animate(t, e, i, s.fn); }, t.prototype.scrollToElement = function (t, e, i, s, o) { if (t && (t = t.nodeType ? t : this.scroller.querySelector(t), !this.options.wheel || t.classList.contains(this.options.wheel.wheelItemClass))) { const n = E(t); n.left -= this.wrapperOffset.left, n.top -= this.wrapperOffset.top, !0 === i && (i = Math.round(t.offsetWidth / 2 - this.wrapper.offsetWidth / 2)), !0 === s && (s = Math.round(t.offsetHeight / 2 - this.wrapper.offsetHeight / 2)), n.left -= i || 0, n.top -= s || 0, n.left = n.left > this.minScrollX ? this.minScrollX : n.left < this.maxScrollX ? this.maxScrollX : n.left, n.top = n.top > this.minScrollY ? this.minScrollY : n.top < this.maxScrollY ? this.maxScrollY : n.top, this.options.wheel && (n.top = this._findNearestValidWheel(n.top).y), this.scrollTo(n.left, n.top, e, o); } }, t.prototype.resetPosition = function () { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : j.bounce; let i = this.x; const s = Math.round(i); !this.hasHorizontalScroll || s > this.minScrollX ? i = this.minScrollX : s < this.maxScrollX && (i = this.maxScrollX); let o = this.y; const n = Math.round(o); return !this.hasVerticalScroll || n > this.minScrollY ? o = this.minScrollY : n < this.maxScrollY && (o = this.maxScrollY), (i !== this.x || o !== this.y) && (this.scrollTo(i, o, t, e), !0); }, t.prototype.getComputedPosition = function () { let t = window.getComputedStyle(this.scroller, null); let e = void 0; let i = void 0; return this.options.useTransform ? (t = t[O.transform].split(')')[0].split(', '), e = +(t[12] || t[4]), i = +(t[13] || t[5])) : (e = +t.left.replace(/[^-\d.]/g, ''), i = +t.top.replace(/[^-\d.]/g, '')), { x: e, y: i }; }, t.prototype.stop = function () { if (this.options.useTransition && this.isInTransition) { this.isInTransition = !1, tt(this.probeTimer); const t = this.getComputedPosition(); this._translate(t.x, t.y), this.options.wheel ? this.target = this.items[this._findNearestValidWheel(t.y).index] : this.trigger('scrollEnd', { x: this.x, y: this.y }), this.stopFromTransition = !0; } else !this.options.useTransition && this.isAnimating && (this.isAnimating = !1, tt(this.animateTimer), this.trigger('scrollEnd', { x: this.x, y: this.y }), this.stopFromTransition = !0); }, t.prototype.destroy = function () { this.destroyed = !0, this.trigger('destroy'), this.options.useTransition ? tt(this.probeTimer) : tt(this.animateTimer), this._removeDOMEvents(), this._events = {}; }; } function ct(t) {
      t.prototype._initSnap = function () {
        const t = this; this.currentPage = {}; const e = this.options.snap; if (e.loop) { const i = this.scroller.children; i.length > 1 ? (U(i[i.length - 1].cloneNode(!0), this.scroller), this.scroller.appendChild(i[1].cloneNode(!0))) : e.loop = !1; } let s = e.el; typeof s === 'string' && (s = this.scroller.querySelectorAll(s)), this.on('refresh', () => {
          if (t.pages = [], t.wrapperWidth && t.wrapperHeight && t.scrollerWidth && t.scrollerHeight) {
            const i = e.stepX || t.wrapperWidth; const o = e.stepY || t.wrapperHeight; let n = 0; let r = void 0; let a = void 0; let h = void 0; let l = 0; let c = void 0; let p = 0; let u = void 0; let d = void 0; if (s) {
              for (c = s.length, u = -1; l < c; l++) {
                d = F(s[l]), (l === 0 || d.left <= F(s[l - 1]).left) && (p = 0, u++), t.pages[p] || (t.pages[p] = []), n = Math.max(-d.left, t.maxScrollX), r = Math.max(-d.top, t.maxScrollY), a = n - Math.round(d.width / 2), h = r - Math.round(d.height / 2), t.pages[p][u] = {
                  x: n, y: r, width: d.width, height: d.height, cx: a, cy: h,
                }, n > t.maxScrollX && p++;
              }
            } else {
              a = Math.round(i / 2), h = Math.round(o / 2); while (n > -t.scrollerWidth) {
                t.pages[l] = [], c = 0, r = 0; while (r > -t.scrollerHeight) {
                  t.pages[l][c] = {
                    x: Math.max(n, t.maxScrollX), y: Math.max(r, t.maxScrollY), width: i, height: o, cx: n - a, cy: r - h,
                  }, r -= o, c++;
                } n -= i, l++;
              }
            }t._checkSnapLoop(); const m = e._loopX ? 1 : 0; const f = e._loopY ? 1 : 0; t._goToPage(t.currentPage.pageX || m, t.currentPage.pageY || f, 0, void 0, !0); const g = e.threshold; g % 1 === 0 ? (t.snapThresholdX = g, t.snapThresholdY = g) : (t.snapThresholdX = Math.round(t.pages[t.currentPage.pageX][t.currentPage.pageY].width * g), t.snapThresholdY = Math.round(t.pages[t.currentPage.pageX][t.currentPage.pageY].height * g));
          }
        }), this.on('scrollEnd', () => { e.loop && (e._loopX ? (t.currentPage.pageX === 0 && t._goToPage(t.pages.length - 2, t.currentPage.pageY, 0, void 0, !0), t.currentPage.pageX === t.pages.length - 1 && t._goToPage(1, t.currentPage.pageY, 0, void 0, !0)) : (t.currentPage.pageY === 0 && t._goToPage(t.currentPage.pageX, t.pages[0].length - 2, 0, void 0, !0), t.currentPage.pageY === t.pages[0].length - 1 && t._goToPage(t.currentPage.pageX, 1, 0, void 0, !0))); }), !1 !== e.listenFlick && this.on('flick', () => { const i = e.speed || Math.max(Math.max(Math.min(Math.abs(t.x - t.startX), 1e3), Math.min(Math.abs(t.y - t.startY), 1e3)), 300); t._goToPage(t.currentPage.pageX + t.directionX, t.currentPage.pageY + t.directionY, i); }), this.on('destroy', () => { if (e.loop) { const i = t.scroller.children; i.length > 2 && (V(t.scroller, i[i.length - 1]), V(t.scroller, i[0])); } });
      }, t.prototype._checkSnapLoop = function () { const t = this.options.snap; t.loop && this.pages && this.pages.length && (this.pages.length > 1 && (t._loopX = !0), this.pages[0] && this.pages[0].length > 1 && (t._loopY = !0), t._loopX && t._loopY && at('Loop does not support two direction at the same time.')); }, t.prototype._nearestSnap = function (t, e) {
        if (!this.pages.length) {
          return {
            x: 0, y: 0, pageX: 0, pageY: 0,
          };
        } let i = 0; if (Math.abs(t - this.absStartX) <= this.snapThresholdX && Math.abs(e - this.absStartY) <= this.snapThresholdY) return this.currentPage; t > this.minScrollX ? t = this.minScrollX : t < this.maxScrollX && (t = this.maxScrollX), e > this.minScrollY ? e = this.minScrollY : e < this.maxScrollY && (e = this.maxScrollY); for (var s = this.pages.length; i < s; i++) if (t >= this.pages[i][0].cx) { t = this.pages[i][0].x; break; }s = this.pages[i].length; for (var o = 0; o < s; o++) if (e >= this.pages[0][o].cy) { e = this.pages[0][o].y; break; } return i === this.currentPage.pageX && (i += this.directionX, i < 0 ? i = 0 : i >= this.pages.length && (i = this.pages.length - 1), t = this.pages[i][0].x), o === this.currentPage.pageY && (o += this.directionY, o < 0 ? o = 0 : o >= this.pages[0].length && (o = this.pages[0].length - 1), e = this.pages[0][o].y), {
          x: t, y: e, pageX: i, pageY: o,
        };
      }, t.prototype._goToPage = function (t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; let i = arguments[2]; let s = arguments[3]; const o = arguments[4]; const n = this.options.snap; if (n && this.pages && this.pages.length && (s = s || n.easing || j.bounce, t >= this.pages.length ? t = this.pages.length - 1 : t < 0 && (t = 0), this.pages[t])) {
          e >= this.pages[t].length ? e = this.pages[t].length - 1 : e < 0 && (e = 0); const r = this.pages[t][e].x; const a = this.pages[t][e].y; i = void 0 === i ? n.speed || Math.max(Math.max(Math.min(Math.abs(r - this.x), 1e3), Math.min(Math.abs(a - this.y), 1e3)), 300) : i, this.currentPage = {
            x: r, y: a, pageX: t, pageY: e,
          }, this.scrollTo(r, a, i, s, o);
        }
      }, t.prototype.goToPage = function (t, e, i, s) { const o = this.options.snap; if (o && this.pages && this.pages.length) { if (o.loop) { let n = void 0; o._loopX ? (n = this.pages.length - 2, t >= n ? t = n - 1 : t < 0 && (t = 0), t += 1) : (n = this.pages[0].length - 2, e >= n ? e = n - 1 : e < 0 && (e = 0), e += 1); } this._goToPage(t, e, i, s); } }, t.prototype.next = function (t, e) { const i = this.options.snap; if (i) { let s = this.currentPage.pageX; let o = this.currentPage.pageY; s++, s >= this.pages.length && this.hasVerticalScroll && (s = 0, o++), this._goToPage(s, o, t, e); } }, t.prototype.prev = function (t, e) { const i = this.options.snap; if (i) { let s = this.currentPage.pageX; let o = this.currentPage.pageY; s--, s < 0 && this.hasVerticalScroll && (s = 0, o--), this._goToPage(s, o, t, e); } }, t.prototype.getCurrentPage = function () { const t = this.options.snap; if (!t) return null; if (t.loop) { let e = void 0; return e = t._loopX ? y({}, this.currentPage, { pageX: this.currentPage.pageX - 1 }) : y({}, this.currentPage, { pageY: this.currentPage.pageY - 1 }), e; } return this.currentPage; };
    } function pt(t) { t.prototype.wheelTo = function () { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; if (this.options.wheel) { const e = -t * this.itemHeight; this.scrollTo(0, e); } }, t.prototype.getSelectedIndex = function () { return this.options.wheel && this.selectedIndex; }, t.prototype._initWheel = function () { const t = this.options.wheel; t.wheelWrapperClass || (t.wheelWrapperClass = 'wheel-scroll'), t.wheelItemClass || (t.wheelItemClass = 'wheel-item'), t.wheelDisabledItemClass || (t.wheelDisabledItemClass = 'wheel-disabled-item'), void 0 === t.selectedIndex && (t.selectedIndex = 0); }, t.prototype._findNearestValidWheel = function (t) { t = t > 0 ? 0 : t < this.maxScrollY ? this.maxScrollY : t; const e = this.options.wheel; let i = Math.abs(Math.round(-t / this.itemHeight)); const s = i; const o = this.items; while (i >= 0) { if (o[i].className.indexOf(e.wheelDisabledItemClass) === -1) break; i--; } if (i < 0) { i = s; while (i <= o.length - 1) { if (o[i].className.indexOf(e.wheelDisabledItemClass) === -1) break; i++; } } return i === o.length && (i = s), { index: this.wheelItemsAllDisabled ? -1 : i, y: -i * this.itemHeight }; }, t.prototype._checkWheelAllDisabled = function () { const t = this.options.wheel; const e = this.items; this.wheelItemsAllDisabled = !0; for (let i = 0; i < e.length; i++) if (e[i].className.indexOf(t.wheelDisabledItemClass) === -1) { this.wheelItemsAllDisabled = !1; break; } }; } const ut = 8; function dt(t) {
      t.prototype._initScrollbar = function () {
        const t = this; const e = this.options.scrollbar; const i = e.fade; const s = void 0 === i || i; const o = e.interactive; const n = void 0 !== o && o; this.indicators = []; let r = void 0; this.options.scrollX && (r = {
          el: mt('horizontal'), direction: 'horizontal', fade: s, interactive: n,
        }, this._insertScrollBar(r.el), this.indicators.push(new ft(this, r))), this.options.scrollY && (r = {
          el: mt('vertical'), direction: 'vertical', fade: s, interactive: n,
        }, this._insertScrollBar(r.el), this.indicators.push(new ft(this, r))), this.on('refresh', () => { for (let e = 0; e < t.indicators.length; e++)t.indicators[e].refresh(); }), s && (this.on('scrollEnd', () => { for (let e = 0; e < t.indicators.length; e++)t.indicators[e].fade(); }), this.on('scrollCancel', () => { for (let e = 0; e < t.indicators.length; e++)t.indicators[e].fade(); }), this.on('scrollStart', () => { for (let e = 0; e < t.indicators.length; e++)t.indicators[e].fade(!0); }), this.on('beforeScrollStart', () => { for (let e = 0; e < t.indicators.length; e++)t.indicators[e].fade(!0, !0); })), this.on('destroy', () => { t._removeScrollBars(); });
      }, t.prototype._insertScrollBar = function (t) { this.wrapper.appendChild(t); }, t.prototype._removeScrollBars = function () { for (let t = 0; t < this.indicators.length; t++) this.indicators[t].destroy(); };
    } function mt(t) { const e = document.createElement('div'); const i = document.createElement('div'); return e.style.cssText = 'position:absolute;z-index:9999;pointerEvents:none', i.style.cssText = 'box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px;', i.className = 'bscroll-indicator', t === 'horizontal' ? (e.style.cssText += ';height:7px;left:2px;right:2px;bottom:0', i.style.height = '100%', e.className = 'bscroll-horizontal-scrollbar') : (e.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px', i.style.width = '100%', e.className = 'bscroll-vertical-scrollbar'), e.style.cssText += ';overflow:hidden', e.appendChild(i), e; } function ft(t, e) { this.wrapper = e.el, this.wrapperStyle = this.wrapper.style, this.indicator = this.wrapper.children[0], this.indicatorStyle = this.indicator.style, this.scroller = t, this.direction = e.direction, e.fade ? (this.visible = 0, this.wrapperStyle.opacity = '0') : this.visible = 1, this.sizeRatioX = 1, this.sizeRatioY = 1, this.maxPosX = 0, this.maxPosY = 0, this.x = 0, this.y = 0, e.interactive && this._addDOMEvents(); } function gt(t) { t.prototype._initPullDown = function () { this.options.probeType = rt; }, t.prototype._checkPullDown = function () { const t = this.options.pullDownRefresh; const e = t.threshold; const i = void 0 === e ? 90 : e; const s = t.stop; const o = void 0 === s ? 40 : s; return !(this.directionY !== it || this.y < i) && (this.pulling || (this.pulling = !0, this.trigger('pullingDown')), this.scrollTo(this.x, o, this.options.bounceTime, j.bounce), this.pulling); }, t.prototype.finishPullDown = function () { this.pulling = !1, this.resetPosition(this.options.bounceTime, j.bounce); }, t.prototype.openPullDown = function () { const t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; this.options.pullDownRefresh = t, this._initPullDown(); }, t.prototype.closePullDown = function () { this.options.pullDownRefresh = !1; }, t.prototype.autoPullDownRefresh = function () { const t = this.options.pullDownRefresh; const e = t.threshold; const i = void 0 === e ? 90 : e; const s = t.stop; const o = void 0 === s ? 40 : s; this.pulling || (this.pulling = !0, this.scrollTo(this.x, i), this.trigger('pullingDown'), this.scrollTo(this.x, o, this.options.bounceTime, j.bounce)); }; } function vt(t) { t.prototype._initPullUp = function () { this.options.probeType = rt, this.pullupWatching = !1, this._watchPullUp(); }, t.prototype._watchPullUp = function () { this.pullupWatching || (this.pullupWatching = !0, this.on('scroll', this._checkToEnd)); }, t.prototype._checkToEnd = function (t) { const e = this; const i = this.options.pullUpLoad.threshold; const s = void 0 === i ? 0 : i; this.movingDirectionY === et && t.y <= this.maxScrollY + s && (this.once('scrollEnd', () => { e.pullupWatching = !1; }), this.trigger('pullingUp'), this.off('scroll', this._checkToEnd)); }, t.prototype.finishPullUp = function () { const t = this; this.pullupWatching ? this.once('scrollEnd', () => { t._watchPullUp(); }) : this._watchPullUp(); }, t.prototype.openPullUp = function () { const t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; this.options.pullUpLoad = t, this._initPullUp(); }, t.prototype.closePullUp = function () { this.options.pullUpLoad = !1, this.pullupWatching && (this.pullupWatching = !1, this.off('scroll', this._checkToEnd)); }; } function yt(t) { t.prototype._initMouseWheel = function () { const t = this; this._handleMouseWheelEvent(_), this.on('destroy', () => { clearTimeout(t.mouseWheelTimer), clearTimeout(t.mouseWheelEndTimer), t._handleMouseWheelEvent(A); }), this.firstWheelOpreation = !0; }, t.prototype._handleMouseWheelEvent = function (t) { t(this.wrapper, 'wheel', this), t(this.wrapper, 'mousewheel', this), t(this.wrapper, 'DOMMouseScroll', this); }, t.prototype._onMouseWheel = function (t) { const e = this; if (this.enabled) { t.preventDefault(), this.options.stopPropagation && t.stopPropagation(), this.firstWheelOpreation && this.trigger('scrollStart'), this.firstWheelOpreation = !1; const i = this.options.mouseWheel; const s = i.speed; const o = void 0 === s ? 20 : s; const n = i.invert; const r = void 0 !== n && n; const a = i.easeTime; const h = void 0 === a ? 300 : a; clearTimeout(this.mouseWheelTimer), this.mouseWheelTimer = setTimeout(() => { e.options.snap || h || e.trigger('scrollEnd', { x: e.x, y: e.y }), e.firstWheelOpreation = !0; }, 400); let l = void 0; let c = void 0; switch (!0) { case 'deltaX' in t: t.deltaMode === 1 ? (l = -t.deltaX * o, c = -t.deltaY * o) : (l = -t.deltaX, c = -t.deltaY); break; case 'wheelDeltaX' in t: l = t.wheelDeltaX / 120 * o, c = t.wheelDeltaY / 120 * o; break; case 'wheelDelta' in t: l = c = t.wheelDelta / 120 * o; break; case 'detail' in t: l = c = -t.detail / 3 * o; break; default: return; } const p = r ? -1 : 1; l *= p, c *= p, this.hasVerticalScroll || (l = c, c = 0); let u = void 0; let d = void 0; if (this.options.snap) return u = this.currentPage.pageX, d = this.currentPage.pageY, l > 0 ? u-- : l < 0 && u++, c > 0 ? d-- : c < 0 && d++, void this._goToPage(u, d); u = this.x + Math.round(this.hasHorizontalScroll ? l : 0), d = this.y + Math.round(this.hasVerticalScroll ? c : 0), this.movingDirectionX = this.directionX = l > 0 ? -1 : l < 0 ? 1 : 0, this.movingDirectionY = this.directionY = c > 0 ? -1 : c < 0 ? 1 : 0, u > this.minScrollX ? u = this.minScrollX : u < this.maxScrollX && (u = this.maxScrollX), d > this.minScrollY ? d = this.minScrollY : d < this.maxScrollY && (d = this.maxScrollY); const m = this.y === d; this.scrollTo(u, d, h, j.swipe), this.trigger('scroll', { x: this.x, y: this.y }), clearTimeout(this.mouseWheelEndTimer), m && (this.mouseWheelEndTimer = setTimeout(() => { e.trigger('scrollEnd', { x: e.x, y: e.y }); }, h)); } }; } function bt(t) { t.prototype._initZoom = function () { const t = this.options.zoom; const e = t.start; const i = void 0 === e ? 1 : e; const s = t.min; const o = void 0 === s ? 1 : s; const n = t.max; const r = void 0 === n ? 4 : n; this.scale = Math.min(Math.max(i, o), r), this.setScale(this.scale), this.scrollerStyle[O.transformOrigin] = '0 0'; }, t.prototype._zoomTo = function (t, e, i, s) { this.scaled = !0; const o = t / (s || this.scale); this.setScale(t), this.refresh(); let n = Math.round(this.startX - (e - this.relativeX) * (o - 1)); let r = Math.round(this.startY - (i - this.relativeY) * (o - 1)); n > this.minScrollX ? n = this.minScrollX : n < this.maxScrollX && (n = this.maxScrollX), r > this.minScrollY ? r = this.minScrollY : r < this.maxScrollY && (r = this.maxScrollY), this.x === n && this.y === r || this.scrollTo(n, r, this.options.bounceTime), this.scaled = !1; }, t.prototype.zoomTo = function (t, e, i) { const s = Y(this.wrapper); const o = s.left; const n = s.top; const r = e + o - this.x; const a = i + n - this.y; this._zoomTo(t, r, a); }, t.prototype._zoomStart = function (t) { const e = t.touches[0]; const i = t.touches[1]; const s = Math.abs(e.pageX - i.pageX); const o = Math.abs(e.pageY - i.pageY); this.startDistance = w(s, o), this.startScale = this.scale; const n = Y(this.wrapper); const r = n.left; const a = n.top; this.originX = Math.abs(e.pageX + i.pageX) / 2 + r - this.x, this.originY = Math.abs(e.pageY + i.pageY) / 2 + a - this.y, this.trigger('zoomStart'); }, t.prototype._zoom = function (t) { if (this.enabled && !this.destroyed && W[t.type] === this.initiated) { this.options.preventDefault && t.preventDefault(), this.options.stopPropagation && t.stopPropagation(); const e = t.touches[0]; const i = t.touches[1]; const s = Math.abs(e.pageX - i.pageX); const o = Math.abs(e.pageY - i.pageY); const n = w(s, o); let r = n / this.startDistance * this.startScale; this.scaled = !0; const a = this.options.zoom; const h = a.min; const l = void 0 === h ? 1 : h; const c = a.max; const p = void 0 === c ? 4 : c; r < l ? r = 0.5 * l * Math.pow(2, r / l) : r > p && (r = 2 * p * Math.pow(0.5, p / r)); const u = r / this.startScale; const d = this.startX - (this.originX - this.relativeX) * (u - 1); const m = this.startY - (this.originY - this.relativeY) * (u - 1); this.setScale(r), this.scrollTo(d, m, 0); } }, t.prototype._zoomEnd = function (t) { if (this.enabled && !this.destroyed && W[t.type] === this.initiated) { this.options.preventDefault && t.preventDefault(), this.options.stopPropagation && t.stopPropagation(), this.isInTransition = !1, this.isAnimating = !1, this.initiated = 0; const e = this.options.zoom; const i = e.min; const s = void 0 === i ? 1 : i; const o = e.max; const n = void 0 === o ? 4 : o; const r = this.scale > n ? n : this.scale < s ? s : this.scale; this._zoomTo(r, this.originX, this.originY, this.startScale), this.trigger('zoomEnd'); } }; }ft.prototype.handleEvent = function (t) { switch (t.type) { case 'touchstart': case 'mousedown': this._start(t); break; case 'touchmove': case 'mousemove': this._move(t); break; case 'touchend': case 'mouseup': case 'touchcancel': case 'mousecancel': this._end(t); break; } }, ft.prototype.refresh = function () { this._shouldShow() && (this.transitionTime(), this._calculate(), this.updatePosition()); }, ft.prototype.fade = function (t, e) { const i = this; if (!e || this.visible) { const s = t ? 250 : 500; t = t ? '1' : '0', this.wrapperStyle[O.transitionDuration] = `${s}ms`, clearTimeout(this.fadeTimeout), this.fadeTimeout = setTimeout(() => { i.wrapperStyle.opacity = t, i.visible = +t; }, 0); } }, ft.prototype.updatePosition = function () { if (this.direction === 'vertical') { let t = Math.round(this.sizeRatioY * this.scroller.y); if (t < 0) { this.transitionTime(500); const e = Math.max(this.indicatorHeight + 3 * t, ut); this.indicatorStyle.height = `${e}px`, t = 0; } else if (t > this.maxPosY) { this.transitionTime(500); const i = Math.max(this.indicatorHeight - 3 * (t - this.maxPosY), ut); this.indicatorStyle.height = `${i}px`, t = this.maxPosY + this.indicatorHeight - i; } else this.indicatorStyle.height = `${this.indicatorHeight}px`; this.y = t, this.scroller.options.useTransform ? this.indicatorStyle[O.transform] = `translateY(${t}px)${this.scroller.translateZ}` : this.indicatorStyle.top = `${t}px`; } else { let s = Math.round(this.sizeRatioX * this.scroller.x); if (s < 0) { this.transitionTime(500); const o = Math.max(this.indicatorWidth + 3 * s, ut); this.indicatorStyle.width = `${o}px`, s = 0; } else if (s > this.maxPosX) { this.transitionTime(500); const n = Math.max(this.indicatorWidth - 3 * (s - this.maxPosX), ut); this.indicatorStyle.width = `${n}px`, s = this.maxPosX + this.indicatorWidth - n; } else this.indicatorStyle.width = `${this.indicatorWidth}px`; this.x = s, this.scroller.options.useTransform ? this.indicatorStyle[O.transform] = `translateX(${s}px)${this.scroller.translateZ}` : this.indicatorStyle.left = `${s}px`; } }, ft.prototype.transitionTime = function () { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; this.indicatorStyle[O.transitionDuration] = `${t}ms`; }, ft.prototype.transitionTimingFunction = function (t) { this.indicatorStyle[O.transitionTimingFunction] = t; }, ft.prototype.destroy = function () { this._removeDOMEvents(), this.wrapper.parentNode.removeChild(this.wrapper); }, ft.prototype._start = function (t) { const e = t.touches ? t.touches[0] : t; t.preventDefault(), t.stopPropagation(), this.transitionTime(), this.initiated = !0, this.moved = !1, this.lastPointX = e.pageX, this.lastPointY = e.pageY, this.startTime = v(), this._handleMoveEvents(_), this.scroller.trigger('beforeScrollStart'); }, ft.prototype._move = function (t) { const e = t.touches ? t.touches[0] : t; t.preventDefault(), t.stopPropagation(), this.moved || this.scroller.trigger('scrollStart'), this.moved = !0; const i = e.pageX - this.lastPointX; this.lastPointX = e.pageX; const s = e.pageY - this.lastPointY; this.lastPointY = e.pageY; const o = this.x + i; const n = this.y + s; this._pos(o, n); }, ft.prototype._end = function (t) { if (this.initiated) { this.initiated = !1, t.preventDefault(), t.stopPropagation(), this._handleMoveEvents(A); const e = this.scroller.options.snap; if (e) { const i = e.speed; const s = e.easing; const o = void 0 === s ? j.bounce : s; const n = this.scroller._nearestSnap(this.scroller.x, this.scroller.y); const r = i || Math.max(Math.max(Math.min(Math.abs(this.scroller.x - n.x), 1e3), Math.min(Math.abs(this.scroller.y - n.y), 1e3)), 300); this.scroller.x === n.x && this.scroller.y === n.y || (this.scroller.directionX = 0, this.scroller.directionY = 0, this.scroller.currentPage = n, this.scroller.scrollTo(n.x, n.y, r, o)); } this.moved && this.scroller.trigger('scrollEnd', { x: this.scroller.x, y: this.scroller.y }); } }, ft.prototype._pos = function (t, e) { t < 0 ? t = 0 : t > this.maxPosX && (t = this.maxPosX), e < 0 ? e = 0 : e > this.maxPosY && (e = this.maxPosY), t = Math.round(t / this.sizeRatioX), e = Math.round(e / this.sizeRatioY), this.scroller.scrollTo(t, e), this.scroller.trigger('scroll', { x: this.scroller.x, y: this.scroller.y }); }, ft.prototype._shouldShow = function () { return this.direction === 'vertical' && this.scroller.hasVerticalScroll || this.direction === 'horizontal' && this.scroller.hasHorizontalScroll ? (this.wrapper.style.display = '', !0) : (this.wrapper.style.display = 'none', !1); }, ft.prototype._calculate = function () { if (this.direction === 'vertical') { const t = this.wrapper.clientHeight; this.indicatorHeight = Math.max(Math.round(t * t / (this.scroller.scrollerHeight || t || 1)), ut), this.indicatorStyle.height = `${this.indicatorHeight}px`, this.maxPosY = t - this.indicatorHeight, this.sizeRatioY = this.maxPosY / this.scroller.maxScrollY; } else { const e = this.wrapper.clientWidth; this.indicatorWidth = Math.max(Math.round(e * e / (this.scroller.scrollerWidth || e || 1)), ut), this.indicatorStyle.width = `${this.indicatorWidth}px`, this.maxPosX = e - this.indicatorWidth, this.sizeRatioX = this.maxPosX / this.scroller.maxScrollX; } }, ft.prototype._addDOMEvents = function () { const t = _; this._handleDOMEvents(t); }, ft.prototype._removeDOMEvents = function () { const t = A; this._handleDOMEvents(t), this._handleMoveEvents(t); }, ft.prototype._handleMoveEvents = function (t) { this.scroller.options.disableTouch || t(window, 'touchmove', this), this.scroller.options.disableMouse || t(window, 'mousemove', this); }, ft.prototype._handleDOMEvents = function (t) { this.scroller.options.disableTouch || (t(this.indicator, 'touchstart', this), t(window, 'touchend', this)), this.scroller.options.disableMouse || (t(this.indicator, 'mousedown', this), t(window, 'mouseup', this)); }; const wt = 30; const xt = 10; const St = 200; const Tt = 2e3; function _t(t) { t.prototype._initInfinite = function () { this.options.probeType = 3, this.maxScrollY = -Tt, this.infiniteScroller = new Et(this, this.options.infinity); }; } function At(t) { if (t && t.classList) return t.classList.contains('tombstone'); } function Et(t, e) { const i = this; this.options = e, ht(typeof this.options.createTombstone === 'function', 'Infinite scroll need createTombstone Function to create tombstone'), ht(typeof this.options.fetch === 'function', 'Infinite scroll need fetch Function to fetch new data.'), ht(typeof this.options.render === 'function', 'Infinite scroll need render Function to render each item.'), this.firstAttachedItem = 0, this.lastAttachedItem = 0, this.anchorScrollTop = 0, this.anchorItem = { index: 0, offset: 0 }, this.tombstoneHeight = 0, this.tombstoneWidth = 0, this.tombstones = [], this.tombstonesAnimationHandlers = [], this.items = [], this.loadedItems = 0, this.requestInProgress = !1, this.hasMore = !0, this.scroller = t, this.wrapperEl = this.scroller.wrapper, this.scrollerEl = this.scroller.scroller, this.scroller.on('resize', () => { i.onResize(); }), this.scroller.on('destroy', () => { i.destroy(); }), this._onResizeHandler = setTimeout(() => { i.onResize(), i.scroller.on('scroll', () => { i.onScroll(); }); }); } function Yt(t, e) { this.wrapper = typeof t === 'string' ? document.querySelector(t) : t, this.wrapper || at('Can not resolve the wrapper DOM.'), this.scroller = this.wrapper.children[0], this.scroller || at('The wrapper need at least one child element to be scroller.'), this.scrollerStyle = this.scroller.style, this._init(e); }Et.prototype.destroy = function () { const t = this; clearTimeout(this._onResizeHandler), this.tombstonesAnimationHandlers.forEach((t) => { clearTimeout(t); }), this.tombstonesAnimationHandlers = null, this.items.forEach((e) => { e.node && (t.scrollerEl.removeChild(e.node), e.node = null); }), this.scroller.infiniteScroller = null, this.scroller = null, this.wrapperEl = null, this.scrollerEl = null, this.items = null, this.tombstones = null; }, Et.prototype.onScroll = function () { const t = -this.scroller.y; const e = t - this.anchorScrollTop; this.anchorItem = t === 0 ? { index: 0, offset: 0 } : this._calculateAnchoredItem(this.anchorItem, e), this.anchorScrollTop = t; const i = this._calculateAnchoredItem(this.anchorItem, this.scroller.wrapperHeight); let s = this.anchorItem.index; let o = i.index; e < 0 ? (s -= wt, o += xt) : (s -= xt, o += wt), this.fill(s, o), this.maybeRequestContent(); }, Et.prototype.onResize = function () { const t = this.options.createTombstone(); t.style.position = 'absolute', this.scrollerEl.appendChild(t), t.style.display = '', this.tombstoneHeight = t.offsetHeight, this.tombstoneWidth = t.offsetWidth, this.scrollerEl.removeChild(t); for (let e = 0; e < this.items.length; e++) this.items[e].height = this.items[e].width = 0; this.onScroll(); }, Et.prototype.fill = function (t, e) { this.firstAttachedItem = Math.max(0, t), this.hasMore || (e = Math.min(e, this.items.length)), this.lastAttachedItem = e, this.attachContent(); }, Et.prototype.maybeRequestContent = function () { const t = this; if (!this.requestInProgress && this.hasMore) { const e = this.lastAttachedItem - this.loadedItems; e <= 0 || (this.requestInProgress = !0, this.options.fetch(e).then((e) => { if (t.requestInProgress = !1, e)t.addContent(e); else { t.hasMore = !1; const i = t._removeTombstones(); let s = 0; t.anchorItem.index <= t.items.length ? (s = t._fixScrollPosition(), t._setupAnimations({}, s), t.scroller.resetPosition(t.scroller.options.bounceTime)) : (t.anchorItem.index -= i, s = t._fixScrollPosition(), t._setupAnimations({}, s), t.scroller.stop(), t.scroller.resetPosition(), t.onScroll()); } })); } }, Et.prototype.addContent = function (t) { for (let e = 0; e < t.length; e++) this.items.length <= this.loadedItems && this._addItem(), this.items[this.loadedItems++].data = t[e]; this.attachContent(), this.maybeRequestContent(); }, Et.prototype.attachContent = function () { const t = this._collectUnusedNodes(); const e = this._createDOMNodes(t); this._cleanupUnusedNodes(t), this._cacheNodeSize(); const i = this._fixScrollPosition(); this._setupAnimations(e, i); }, Et.prototype.resetMore = function () { this.hasMore = !0; }, Et.prototype._removeTombstones = function () { for (var t = void 0, e = 0, i = this.items.length, s = 0; s < i; s++) { const o = this.items[s].node; const n = this.items[s].data; o && !At(o) || n || (void 0 === t && (t = s), o && this.scrollerEl.removeChild(o)); } return e = i - t, this.items.splice(t), this.lastAttachedItem = Math.min(this.lastAttachedItem, this.items.length), e; }, Et.prototype._collectUnusedNodes = function () { for (var t = [], e = 0; e < this.items.length; e++) if (e !== this.firstAttachedItem) { const i = this.items[e].node; i && (At(i) ? (this.tombstones.push(i), this.tombstones[this.tombstones.length - 1].style.display = 'none') : t.push(i)), this.items[e].node = null; } else e = this.lastAttachedItem - 1; return t; }, Et.prototype._createDOMNodes = function (t) { for (var e = {}, i = this.firstAttachedItem; i < this.lastAttachedItem; i++) { while (this.items.length <= i) this._addItem(); const s = this.items[i].node; const o = this.items[i].data; if (s) { if (!At(s) || !o) continue; s.style.zIndex = 1, e[i] = [s, this.items[i].top - this.anchorScrollTop], this.items[i].node = null; } const n = o ? this.options.render(o, t.pop()) : this._getTombStone(); n.style.position = 'absolute', this.items[i].top = -1, this.scrollerEl.appendChild(n), this.items[i].node = n; } return e; }, Et.prototype._cleanupUnusedNodes = function (t) { while (t.length) this.scrollerEl.removeChild(t.pop()); }, Et.prototype._cacheNodeSize = function () { for (let t = this.firstAttachedItem; t < this.lastAttachedItem; t++) { const e = this.items[t]; if (e.data && !e.height) { const i = At(e.node); e.height = i ? this.tombstoneHeight : e.node.offsetHeight, e.width = i ? this.tombstoneWidth : e.node.offsetWidth; } } }, Et.prototype._fixScrollPosition = function () { this.anchorScrollTop = 0; for (let t = 0; t < this.anchorItem.index; t++) this.anchorScrollTop += this.items[t].height || this.tombstoneHeight; this.anchorScrollTop += this.anchorItem.offset; let e = this.anchorScrollTop - this.anchorItem.offset; let i = this.anchorItem.index; while (i > this.firstAttachedItem)e -= this.items[i - 1].height || this.tombstoneHeight, i--; return e; }, Et.prototype._setupAnimations = function (t, e) { const i = this; for (const s in t) { const o = t[s]; this.items[s].node.style[O.transform] = `translateY(${this.anchorScrollTop + o[1]}px) scale(${this.tombstoneWidth / this.items[s].width}, ${this.tombstoneHeight / this.items[s].height})`, this.items[s].node.offsetTop, o[0].offsetTop, this.items[s].node.style[O.transition] = `${X}transform ${St}ms`; } for (let n = this.firstAttachedItem; n < this.lastAttachedItem; n++) { const r = t[n]; if (r) { const a = r[0]; a.style[O.transition] = `${X}transform ${St}ms, opacity ${St}ms`, a.style[O.transform] = `translateY(${e}px) scale(${this.items[n].width / this.tombstoneWidth}, ${this.items[n].height / this.tombstoneHeight})`, a.style.opacity = 0; }e !== this.items[n].top && (r || (this.items[n].node.style[O.transition] = ''), this.items[n].node.style[O.transform] = `translateY(${e}px)`), this.items[n].top = e, e += this.items[n].height || this.tombstoneHeight; } this.scroller.maxScrollY = -(e - this.scroller.wrapperHeight + (this.hasMore ? Tt : 0)); const h = setTimeout(() => { for (const e in t) { const s = t[e]; s[0].style.display = 'none', i.tombstones.push(s[0]); } }, St); this.tombstonesAnimationHandlers.push(h); }, Et.prototype._getTombStone = function () { const t = this.tombstones.pop(); return t ? (t.style.display = '', t.style.opacity = 1, t.style[O.transform] = '', t.style[O.transition] = '', t) : this.options.createTombstone(); }, Et.prototype._addItem = function () {
      this.items.push({
        data: null, node: null, height: 0, width: 0, top: 0,
      });
    }, Et.prototype._calculateAnchoredItem = function (t, e) { if (e === 0) return t; let i = t.index; let s = 0; if (e += t.offset, e < 0) { while (e < 0 && i > 0 && this.items[i - 1].height)e += this.items[i - 1].height, i--; s = Math.max(-i, Math.ceil(Math.min(e, 0) / this.tombstoneHeight)); } else { while (e > 0 && i < this.items.length && this.items[i].height && this.items[i].height < e)e -= this.items[i].height, i++; (i >= this.items.length || !this.items[i].height) && (s = Math.floor(Math.max(e, 0) / this.tombstoneHeight)); } return i += s, e -= s * this.tombstoneHeight, { index: i, offset: e }; }, Q(Yt), lt(Yt), u(Yt), ct(Yt), pt(Yt), dt(Yt), gt(Yt), vt(Yt), yt(Yt), bt(Yt), _t(Yt), Yt.Version = '1.15.2'; const Xt = Yt; const Mt = {
      props: {
        data: { type: Array, default: null }, probeType: { type: Number, default: 1 }, click: { type: Boolean, default: !0 }, scrollX: { type: Boolean, default: !1 }, listenScroll: { type: Boolean, default: !1 }, pullup: { type: Boolean, default: !1 }, pulldown: { type: Boolean, default: !1 }, beforeScroll: { type: Boolean, default: !1 }, refreshDelay: { type: Number, default: 50 },
      },
      mounted() { const t = this; setTimeout(() => { t.initScroll(); }, 50); },
      methods: {
        initScroll() { const t = this; this.$refs.wrapper && (this.scroll = new Xt(this.$refs.wrapper, { probeType: this.probeType, click: this.click, scrollX: this.scrollX }), this.listenScroll && this.scroll.on('scroll', (e) => { t.$emit('scroll', e); }), this.pullup && this.scroll.on('scrollEnd', () => { t.scroll.y <= t.scroll.maxScrollY + 50 && t.$emit('scrollToEnd'); }), this.pulldown && this.scroll.on('touchend', (e) => { e.y > 50 && t.$emit('pulldown'); }), this.beforeScroll && this.scroll.on('beforeScrollStart', () => { t.$emit('beforeScroll'); })); }, disable() { this.scroll && this.scroll.disable(); }, enable() { this.scroll && this.scroll.enable(); }, refresh() { this.scroll && this.scroll.refresh(); }, scrollTo() { let t; this.scroll && (t = this.scroll).scrollTo.apply(t, arguments); }, scrollToElement() { let t; this.scroll && (t = this.scroll).scrollToElement.apply(t, arguments); },
      },
      watch: { data() { const t = this; setTimeout(() => { t.refresh(); }, this.refreshDelay); } },
    }; const Pt = Mt; const Dt = i('2877'); const It = Object(Dt.a)(Pt, a, h, !1, null, null, null); const kt = It.exports; const Ct = function () {
      const t = this; const e = t.$createElement; const i = t._self._c || e; return i('mu-list-item', {
        attrs: {
          button: '', ripple: '', nested: t.hasChildren, open: t.open, value: t.hasChildren ? null : t.hasName ? t.item.name : t.item.children[0].name, to: t.to,
        },
      }, [t.item.meta && t.item.meta.icon ? i('mu-list-item-action', { staticClass: 'leftIcon' }, [i('mu-icon', { attrs: { value: t.item.meta.icon } })], 1) : t._e(), i('mu-list-item-title', [t._v(t._s(t.$t(`routes.${t.title}`)))]), t.hasChildren ? i('mu-list-item-action', [i('mu-icon', { staticClass: 'toggleIcon', attrs: { value: 'keyboard_arrow_down' } })], 1) : t._e(), t._l(t.item.children, e => i('template', { slot: 'nested' }, [e.cached && !e.meta.hidden ? i('keep-alive', { key: e.path }, [i('app-drawer-item', { attrs: { item: e } })], 1) : e.meta.hidden ? t._e() : i('app-drawer-item', { key: e.path, attrs: { item: e } })], 1))], 2);
    }; const Ot = []; const zt = {
      name: 'AppDrawerItem',
      props: { item: { type: Object, required: !0 }, defaultOpen: { type: Boolean, default: !0 } },
      data() { return { open: this.defaultOpen }; },
      methods: {},
      computed: {
        title() { return this.item.meta.title ? this.item.meta.title : this.item.children[0].meta.title; }, hasName() { return this.item.name && this.item.name !== ''; }, hasChildren() { return this.item.children && this.item.children.length > 1; }, to() { return this.hasChildren ? null : this.item; },
      },
    }; const Ht = zt; const Wt = (i('503f'), Object(Dt.a)(Ht, Ct, Ot, !1, null, '60b0a8a2', null)); const Ft = Wt.exports; const Lt = {
      components: { ScrollContainer: kt, AppDrawerItem: Ft },
      computed: {
        open: { get() { return this.$store.getters['app/drawerOpen']; }, set(t) { this.$store.commit('app/setDrawerOpen', t); } }, docked() { return this.$store.getters['app/drawerDocked']; }, routes() { return this.$store.getters['app/routes']; }, value: { get() { return console.log('name', this.$route.name), this.$route.name; }, set(t) {} },
      },
      methods: { onChange(t) { this.value = t || this.value; } },
    }; const Nt = Lt; const Rt = Object(Dt.a)(Nt, n, r, !1, null, '737ee51e', null); const Bt = Rt.exports; const Ut = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('mu-appbar', { staticClass: 'app-bar', class: t.isOpen, attrs: { color: 'primary' } }, [i('mu-button', { attrs: { slot: 'left', icon: '' }, on: { click: t.toggleDrawerOpen }, slot: 'left' }, [i('mu-icon', { attrs: { value: 'menu' } })], 1), i('mu-breadcrumbs', t._l(t.pathItems, (e, s) => i('mu-breadcrumbs-item', { key: s, staticClass: 'breadcrumbs-item', attrs: { disabled: s === t.pathItems.length - 1, to: t.to(s) } }, [t._v(`\n      ${t._s(t.$t(`routes.${e}`))}\n    `)])), 1), i('fullscreen', { attrs: { slot: 'right' }, slot: 'right' }), i('theme', { attrs: { slot: 'right' }, slot: 'right' }), i('language', { attrs: { slot: 'right' }, slot: 'right' }), i('account', { attrs: { slot: 'right' }, slot: 'right' })], 1); }; const $t = []; const Vt = (i('28a5'), function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('mu-button', { staticClass: 'col-item btn', attrs: { icon: '', title: t.$t('appbar.fullscreen.toggle') }, on: { click: t.toggleFullscreen } }, [i('mu-icon', { attrs: { value: t.icon } })], 1); }); const qt = []; const Qt = i('93bf'); const jt = i.n(Qt); const Gt = {
      data() { return { isFullscreen: !1 }; }, methods: { toggleFullscreen() { jt.a.enabled ? jt.a.toggle(document.querySelector('html')) : this.$alert(this.$t('message.alertScreenFullDisable'), this.$t('alertTitle'), { okLabel: this.$t('message.okLabel'), type: 'warning' }); }, onChange() { this.isFullscreen = jt.a.isFullscreen; } }, mounted() { jt.a.on('change', this.onChange); }, computed: { icon() { return this.isFullscreen ? 'fullscreen_exit' : 'fullscreen'; } },
    }; const Kt = Gt; const Zt = Object(Dt.a)(Kt, Vt, qt, !1, null, null, null); const Jt = Zt.exports; const te = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('mu-menu', { attrs: { flat: '', 'open-on-hover': '' } }, [i('mu-button', { staticClass: 'col-item btn', attrs: { icon: '' } }, [i('mu-icon', { attrs: { value: 'invert_colors' } })], 1), i('mu-list', { attrs: { slot: 'content' }, on: { change: t.onChangeTheme }, slot: 'content' }, [i('mu-list-item', { attrs: { button: '', value: 'light' } }, [i('mu-list-item-title', [t._v(t._s(t.$t('appbar.theme.light')))])], 1), i('mu-list-item', { attrs: { button: '', value: 'dark' } }, [i('mu-list-item-title', [t._v(t._s(t.$t('appbar.theme.dark')))])], 1)], 1)], 1); }; const ee = []; const ie = { methods: { onChangeTheme(t) { this.$store.commit('app/setTheme', t); } } }; const se = ie; const oe = Object(Dt.a)(se, te, ee, !1, null, null, null); const ne = oe.exports; const re = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('mu-menu', { attrs: { flat: '', 'open-on-hover': '' } }, [i('mu-button', { staticClass: 'col-item btn', attrs: { icon: '' } }, [i('mu-icon', { attrs: { value: 'language' } })], 1), i('mu-list', { attrs: { slot: 'content' }, on: { change: t.onChangeLanguage }, slot: 'content' }, [i('mu-list-item', { attrs: { button: '', value: 'zh-CN' } }, [i('mu-list-item-action', [i('img', { staticStyle: { height: '24px' }, attrs: { src: t.zhcnIcon } })]), i('mu-list-item-title', [t._v('简体中文')])], 1), i('mu-list-item', { attrs: { button: '', value: 'en-US' } }, [i('mu-list-item-action', [i('img', { staticStyle: { height: '24px' }, attrs: { src: t.enusIcon } })]), i('mu-list-item-title', [t._v('English')])], 1)], 1)], 1); }; const ae = []; const he = i('b4ee'); const le = i.n(he); const ce = i('a0d1'); const pe = i.n(ce); const ue = { data() { return { enusIcon: le.a, zhcnIcon: pe.a }; }, methods: { onChangeLanguage(t) { this.$store.commit('app/setLanguage', t); } } }; const de = ue; const me = Object(Dt.a)(de, re, ae, !1, null, null, null); const fe = me.exports; const ge = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('mu-menu', { attrs: { flat: '', 'open-on-hover': '' } }, [i('mu-button', { staticClass: 'col-item btn', attrs: { icon: '' } }, [i('img', { attrs: { src: t.avatar } })]), i('mu-list', { attrs: { slot: 'content' }, on: { change: t.onClickMenu }, slot: 'content' }, [i('mu-list-item', { attrs: { button: '', value: 'personalCenter' } }, [i('mu-list-item-content', [i('mu-list-item-title', [t._v(t._s(t.$t('appbar.account.personalCenter')))])], 1)], 1), i('mu-list-item', { attrs: { button: '', value: 'signout' } }, [i('mu-list-item-content', [i('mu-list-item-title', [t._v(t._s(t.$t('appbar.account.signout')))])], 1)], 1)], 1)], 1); }; const ve = []; const ye = { methods: { onClickMenu(t) { switch (console.log('val', t), t) { case 'personalCenter': break; case 'signout': break; default: this.$alert(this.$t('message.alertIllegalOperation'), this.$t('message.alertTitle'), { type: 'error' }); } } }, computed: { avatar() { return this.$store.getters['user/avatar']; } } }; const be = ye; const we = Object(Dt.a)(be, ge, ve, !1, null, null, null); const xe = we.exports; const Se = {
      components: {
        Fullscreen: Jt, Theme: ne, Language: fe, Account: xe,
      },
      methods: { toggleDrawerOpen() { this.$store.commit('app/setDrawerOpen', !this.open); }, to(t) { const e = { path: '/' }; return e.path += this.pathItems.slice(0, t + 1).join('/'), e; } },
      computed: {
        open() { return this.$store.getters['app/drawerOpen']; }, docked() { return this.$store.getters['app/drawerDocked']; }, isOpen() { return this.open && this.docked ? 'is-open' : ''; }, pathItems() { return this.$route.fullPath.split('/').slice(1); },
      },
    }; const Te = Se; const _e = (i('b1e4'), Object(Dt.a)(Te, Ut, $t, !1, null, '311ebbdc', null)); const Ae = _e.exports; const Ee = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('mu-flex', { staticClass: 'app-content', class: t.isOpen }, [i('mu-fade-transition', { attrs: { mode: 'out-in' } }, [i('router-view', { key: this.$route.fullPath })], 1)], 1); }; const Ye = []; const Xe = { computed: { open() { return this.$store.getters['app/drawerOpen']; }, docked() { return this.$store.getters['app/drawerDocked']; }, isOpen() { return this.open && this.docked ? 'is-open' : ''; } } }; const Me = Xe; const Pe = (i('4dea'), Object(Dt.a)(Me, Ee, Ye, !1, null, '1e215bf8', null)); const De = Pe.exports; const Ie = { components: { AppDrawer: Bt, AppBar: Ae, AppContent: De } }; const ke = Ie; const Ce = Object(Dt.a)(ke, s, o, !1, null, '5d8f9bf5', null); e.default = Ce.exports;
  },
  '1bdd': function (t, e, i) {},
  '28a5': function (t, e, i) {
    const s = i('aae3'); const o = i('cb7c'); const n = i('ebd6'); const r = i('0390'); const a = i('9def'); const h = i('5f1b'); const l = i('520a'); const c = i('79e5'); const p = Math.min; const u = [].push; const d = 'split'; const m = 'length'; const f = 'lastIndex'; const g = 4294967295; const v = !c(() => { RegExp(g, 'y'); }); i('214f')('split', 2, (t, e, i, c) => { let y; return y = 'abbc'[d](/(b)*/)[1] == 'c' || 'test'[d](/(?:)/, -1)[m] != 4 || 'ab'[d](/(?:ab)*/)[m] != 2 || '.'[d](/(.?)(.?)/)[m] != 4 || '.'[d](/()()/)[m] > 1 || ''[d](/.?/)[m] ? function (t, e) { const o = String(this); if (void 0 === t && e === 0) return []; if (!s(t)) return i.call(o, t, e); let n; let r; let a; const h = []; const c = (t.ignoreCase ? 'i' : '') + (t.multiline ? 'm' : '') + (t.unicode ? 'u' : '') + (t.sticky ? 'y' : ''); let p = 0; const d = void 0 === e ? g : e >>> 0; const v = new RegExp(t.source, `${c}g`); while (n = l.call(v, o)) { if (r = v[f], r > p && (h.push(o.slice(p, n.index)), n[m] > 1 && n.index < o[m] && u.apply(h, n.slice(1)), a = n[0][m], p = r, h[m] >= d)) break; v[f] === n.index && v[f]++; } return p === o[m] ? !a && v.test('') || h.push('') : h.push(o.slice(p)), h[m] > d ? h.slice(0, d) : h; } : '0'[d](void 0, 0)[m] ? function (t, e) { return void 0 === t && e === 0 ? [] : i.call(this, t, e); } : i, [function (i, s) { const o = t(this); const n = void 0 == i ? void 0 : i[e]; return void 0 !== n ? n.call(i, o, s) : y.call(String(o), i, s); }, function (t, e) { const s = c(y, t, this, e, y !== i); if (s.done) return s.value; const l = o(t); const u = String(this); const d = n(l, RegExp); const m = l.unicode; const f = (l.ignoreCase ? 'i' : '') + (l.multiline ? 'm' : '') + (l.unicode ? 'u' : '') + (v ? 'y' : 'g'); const b = new d(v ? l : `^(?:${l.source})`, f); const w = void 0 === e ? g : e >>> 0; if (w === 0) return []; if (u.length === 0) return h(b, u) === null ? [u] : []; let x = 0; let S = 0; const T = []; while (S < u.length) { b.lastIndex = v ? S : 0; var _; const A = h(b, v ? u : u.slice(S)); if (A === null || (_ = p(a(b.lastIndex + (v ? 0 : S)), u.length)) === x)S = r(u, S, m); else { if (T.push(u.slice(x, S)), T.length === w) return T; for (let E = 1; E <= A.length - 1; E++) if (T.push(A[E]), T.length === w) return T; S = x = _; } } return T.push(u.slice(x)), T; }]; });
  },
  '4dea': function (t, e, i) {
    const s = i('6a0e'); const o = i.n(s); o.a;
  },
  '503f': function (t, e, i) {
    const s = i('520c'); const o = i.n(s); o.a;
  },
  '520c': function (t, e, i) {},
  '5dbc': function (t, e, i) { const s = i('d3f4'); const o = i('8b97').set; t.exports = function (t, e, i) { let n; const r = e.constructor; return r !== i && typeof r === 'function' && (n = r.prototype) !== i.prototype && s(n) && o && o(t, n), t; }; },
  '6a0e': function (t, e, i) {},
  '8b97': function (t, e, i) { const s = i('d3f4'); const o = i('cb7c'); const n = function (t, e) { if (o(t), !s(e) && e !== null) throw TypeError(`${e}: can't set as prototype!`); }; t.exports = { set: Object.setPrototypeOf || ('__proto__' in {} ? (function (t, e, s) { try { s = i('9b43')(Function.call, i('11e9').f(Object.prototype, '__proto__').set, 2), s(t, []), e = !(t instanceof Array); } catch (o) { e = !0; } return function (t, i) { return n(t, i), e ? t.__proto__ = i : s(t, i), t; }; }({}, !1)) : void 0), check: n }; },
  9093(t, e, i) { const s = i('ce10'); const o = i('e11e').concat('length', 'prototype'); e.f = Object.getOwnPropertyNames || function (t) { return s(t, o); }; },
  '93bf': function (t, e, i) {
    /*!
* screenfull
* v4.2.0 - 2019-04-01
* (c) Sindre Sorhus; MIT License
*/
    (function () {
      const e = typeof window !== 'undefined' && typeof window.document !== 'undefined' ? window.document : {}; const i = t.exports; const s = typeof Element !== 'undefined' && 'ALLOW_KEYBOARD_INPUT' in Element; const o = (function () { for (var t, i = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'], ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'], ['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'], ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'], ['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']], s = 0, o = i.length, n = {}; s < o; s++) if (t = i[s], t && t[1] in e) { for (s = 0; s < t.length; s++)n[i[0][s]] = t[s]; return n; } return !1; }()); const n = { change: o.fullscreenchange, error: o.fullscreenerror }; const r = {
        request(t) { return new Promise(((i) => { const n = o.requestFullscreen; var r = function () { this.off('change', r), i(); }.bind(this); t = t || e.documentElement, / Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent) ? t[n]() : t[n](s ? Element.ALLOW_KEYBOARD_INPUT : {}), this.on('change', r); })); }, exit() { return new Promise(((t) => { if (this.isFullscreen) { var i = function () { this.off('change', i), t(); }.bind(this); e[o.exitFullscreen](), this.on('change', i); } else t(); })); }, toggle(t) { return this.isFullscreen ? this.exit() : this.request(t); }, onchange(t) { this.on('change', t); }, onerror(t) { this.on('error', t); }, on(t, i) { const s = n[t]; s && e.addEventListener(s, i, !1); }, off(t, i) { const s = n[t]; s && e.removeEventListener(s, i, !1); }, raw: o,
      }; o ? (Object.defineProperties(r, { isFullscreen: { get() { return Boolean(e[o.fullscreenElement]); } }, element: { enumerable: !0, get() { return e[o.fullscreenElement]; } }, enabled: { enumerable: !0, get() { return Boolean(e[o.fullscreenEnabled]); } } }), i ? (t.exports = r, t.exports.default = r) : window.screenfull = r) : i ? t.exports = !1 : window.screenfull = !1;
    }());
  },
  a0d1(t, e) { t.exports = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAACsElEQVR42u2aS2sTURTHx0xsG5lkZvb1Gc1EF1V8r7U+iitRUb+CSwW/gm7EvdCvICJCqS9ERHHvzkwSnXQqVmyg0KQJ+vfcMzMSpXm4EDIzZ3HI5eYEcn45//+9Z4gGQEtzaAJAAAgAASAABIAAEAACQACkHEB1v4U0xf8D4FCULLj70gigbKF+xET9sImlSwbcop0wAE4Yfd5391rwzhSw8UpHe1HH51OFgfmxAsDFnc3Dm8vT2u6fQ0V33mYYgneecpMCoLLDxuqdKTTvT/K6rwSOmfh00sTydZLAHso7EPiBW7LGqhuGAyj3tHxoahsvM+i8znAxvwtywtwembiRCariyQf8KwaDqR83/8wdWwD0JWuHTNQOhkVQazeoneFq+FnV0LiQ5z31Xm0myO3nGd7pAvtB502GJcSfG3cAkd7XH25F5x3p+ZmOLr2irnF039PeU521vv4oi8bc5oUp/SsfaD8Pcr1zMQEQQVAu3nqSBb5TikdRDUOtaa+1kCXXp6KKA7xjN0ngKkngBEngaFwkEEEg/apYvTsFNHoA0Lp5b5JPAza6YSdILE0w+gWnbXy9sQ34Qmk+xbLG65WbOXyctv/pdhi/Y7AcdEHrMcmgqWFtfgJrDya4/dsLenAfGNLSSgJKJt7sYKmMqQQCM/zxYQu+3c6hsstGZaeNlVs53mPzKw5uff+ygdZiFu0XOvxrxtjMCCN7gE93ehWV7eGvTaHWSxcNNrd+t8Ko9dX5r47ALp0CygjdUtxugo616VDDe86QaVDdDMn5Vad4s4XgIuSkbRosB0cqn//lhI/DiZ4GRwaQ1GlwZAn8PQ2m8ZGYm9pHYvJQVAAIAAEgAASAABAAAkAACAABIAAEgAAQAAJAAMQHgPxTVAAIAAEgAASAABAAAkAACIBUxS8q74mGHxtxPwAAAABJRU5ErkJggg=='; },
  aa77(t, e, i) { const s = i('5ca1'); const o = i('be13'); const n = i('79e5'); const r = i('fdef'); const a = `[${r}]`; const h = '​'; const l = RegExp(`^${a}${a}*`); const c = RegExp(`${a + a}*$`); const p = function (t, e, i) { const o = {}; const a = n(() => !!r[t]() || h[t]() != h); const l = o[t] = a ? e(u) : r[t]; i && (o[i] = l), s(s.P + s.F * a, 'String', o); }; var u = p.trim = function (t, e) { return t = String(o(t)), 1 & e && (t = t.replace(l, '')), 2 & e && (t = t.replace(c, '')), t; }; t.exports = p; },
  aae3(t, e, i) { const s = i('d3f4'); const o = i('2d95'); const n = i('2b4c')('match'); t.exports = function (t) { let e; return s(t) && (void 0 !== (e = t[n]) ? !!e : o(t) == 'RegExp'); }; },
  b1e4(t, e, i) {
    const s = i('1bdd'); const o = i.n(s); o.a;
  },
  b4ee(t, e) { t.exports = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABCklEQVR42u3YPQqDQBCG4e0sdgvBA0RUPITnDKRa0qSNiCfTE3ypYshfp+zCvMI0U+nj7jerTpKzXKYfHgAAAAAAAAAAAAAAACTn3FkpSs6lqV8AIUR13STv43aD3h/TCyHmB9C2oySpaabthk+n+yG9vp/zA/A+qq5HhRBVlle17aSquh3Se66KhNf/DCiKi4Zh1rq+3t7evS0DcgIwvwLIgBQrICeAzwxYlu99vFcvy3MAGZAiA5gCGZ8DyABrU4BzABmQIAOYAnwL8Ecou28Bk/8EZe8CAIA3gFR7MZsMAMA6ACEIAFOAEASAKUAIAsAUIAQBAMDoGDRZAAAAAAAAAAAAAAAAYLQeaH2goIfBISIAAAAASUVORK5CYII='; },
  c5f6(t, e, i) {
    const s = i('7726'); const o = i('69a8'); const n = i('2d95'); const r = i('5dbc'); const a = i('6a99'); const h = i('79e5'); const l = i('9093').f; const c = i('11e9').f; const p = i('86cc').f; const u = i('aa77').trim; const d = 'Number'; let m = s[d]; const f = m; const g = m.prototype; const v = n(i('2aeb')(g)) == d; const y = 'trim' in String.prototype; const b = function (t) { let e = a(t, !1); if (typeof e === 'string' && e.length > 2) { e = y ? e.trim() : u(e, 3); let i; let s; let o; const n = e.charCodeAt(0); if (n === 43 || n === 45) { if (i = e.charCodeAt(2), i === 88 || i === 120) return NaN; } else if (n === 48) { switch (e.charCodeAt(1)) { case 66: case 98: s = 2, o = 49; break; case 79: case 111: s = 8, o = 55; break; default: return +e; } for (var r, h = e.slice(2), l = 0, c = h.length; l < c; l++) if (r = h.charCodeAt(l), r < 48 || r > o) return NaN; return parseInt(h, s); } } return +e; }; if (!m(' 0o1') || !m('0b1') || m('+0x1')) { m = function (t) { const e = arguments.length < 1 ? 0 : t; const i = this; return i instanceof m && (v ? h(() => { g.valueOf.call(i); }) : n(i) != d) ? r(new f(b(e)), i, m) : b(e); }; for (var w, x = i('9e1e') ? l(f) : 'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'.split(','), S = 0; x.length > S; S++)o(f, w = x[S]) && !o(m, w) && p(m, w, c(f, w)); m.prototype = g, g.constructor = m, i('2aba')(s, d, m); }
  },
  fdef(t, e) { t.exports = '\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff'; },
}]);
